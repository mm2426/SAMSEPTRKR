
SAMSEPTRKR.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002684  00400000  00400000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000438  20000000  00402684  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002250  20000438  00402ac0  00020438  2**3
                  ALLOC
  3 .stack        00003000  20002688  00404d10  00020438  2**0
                  ALLOC
  4 .ARM.attributes 0000002a  00000000  00000000  00020438  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020462  2**0
                  CONTENTS, READONLY
  6 .debug_info   0000bf59  00000000  00000000  000204bb  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000024f0  00000000  00000000  0002c414  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00007ae4  00000000  00000000  0002e904  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000ac0  00000000  00000000  000363e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000a78  00000000  00000000  00036ea8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00005a2d  00000000  00000000  00037920  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000c8e8  00000000  00000000  0003d34d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000545f5  00000000  00000000  00049c35  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001a9c  00000000  00000000  0009e22c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	20005688 	.word	0x20005688
  400004:	00400a49 	.word	0x00400a49
  400008:	00400a45 	.word	0x00400a45
  40000c:	00400a45 	.word	0x00400a45
  400010:	00400a45 	.word	0x00400a45
  400014:	00400a45 	.word	0x00400a45
  400018:	00400a45 	.word	0x00400a45
	...
  40002c:	00400d71 	.word	0x00400d71
  400030:	00400a45 	.word	0x00400a45
  400034:	00000000 	.word	0x00000000
  400038:	00400ded 	.word	0x00400ded
  40003c:	00400e29 	.word	0x00400e29
  400040:	00400a45 	.word	0x00400a45
  400044:	00400a45 	.word	0x00400a45
  400048:	00400a45 	.word	0x00400a45
  40004c:	00400a45 	.word	0x00400a45
  400050:	00400a45 	.word	0x00400a45
  400054:	00400a45 	.word	0x00400a45
  400058:	00400a45 	.word	0x00400a45
  40005c:	00400a45 	.word	0x00400a45
  400060:	0040058d 	.word	0x0040058d
  400064:	0040059d 	.word	0x0040059d
  400068:	00000000 	.word	0x00000000
  40006c:	00400925 	.word	0x00400925
  400070:	00400939 	.word	0x00400939
  400074:	0040094d 	.word	0x0040094d
  400078:	00400a45 	.word	0x00400a45
  40007c:	00400a45 	.word	0x00400a45
	...
  400088:	00400a45 	.word	0x00400a45
  40008c:	00400355 	.word	0x00400355
  400090:	00400365 	.word	0x00400365
  400094:	00400a45 	.word	0x00400a45
  400098:	00400a45 	.word	0x00400a45
  40009c:	00400a45 	.word	0x00400a45
  4000a0:	00400a45 	.word	0x00400a45
  4000a4:	00400a45 	.word	0x00400a45
  4000a8:	00400a45 	.word	0x00400a45
  4000ac:	00400a45 	.word	0x00400a45
  4000b0:	00400a45 	.word	0x00400a45
  4000b4:	00400a45 	.word	0x00400a45
  4000b8:	00400a45 	.word	0x00400a45
  4000bc:	00400a45 	.word	0x00400a45
  4000c0:	00400a45 	.word	0x00400a45
  4000c4:	00400a45 	.word	0x00400a45
  4000c8:	00400a45 	.word	0x00400a45

004000cc <__do_global_dtors_aux>:
  4000cc:	b510      	push	{r4, lr}
  4000ce:	4c05      	ldr	r4, [pc, #20]	; (4000e4 <__do_global_dtors_aux+0x18>)
  4000d0:	7823      	ldrb	r3, [r4, #0]
  4000d2:	b933      	cbnz	r3, 4000e2 <__do_global_dtors_aux+0x16>
  4000d4:	4b04      	ldr	r3, [pc, #16]	; (4000e8 <__do_global_dtors_aux+0x1c>)
  4000d6:	b113      	cbz	r3, 4000de <__do_global_dtors_aux+0x12>
  4000d8:	4804      	ldr	r0, [pc, #16]	; (4000ec <__do_global_dtors_aux+0x20>)
  4000da:	f3af 8000 	nop.w
  4000de:	2301      	movs	r3, #1
  4000e0:	7023      	strb	r3, [r4, #0]
  4000e2:	bd10      	pop	{r4, pc}
  4000e4:	20000438 	.word	0x20000438
  4000e8:	00000000 	.word	0x00000000
  4000ec:	00402684 	.word	0x00402684

004000f0 <frame_dummy>:
  4000f0:	4b08      	ldr	r3, [pc, #32]	; (400114 <frame_dummy+0x24>)
  4000f2:	b510      	push	{r4, lr}
  4000f4:	b11b      	cbz	r3, 4000fe <frame_dummy+0xe>
  4000f6:	4908      	ldr	r1, [pc, #32]	; (400118 <frame_dummy+0x28>)
  4000f8:	4808      	ldr	r0, [pc, #32]	; (40011c <frame_dummy+0x2c>)
  4000fa:	f3af 8000 	nop.w
  4000fe:	4808      	ldr	r0, [pc, #32]	; (400120 <frame_dummy+0x30>)
  400100:	6803      	ldr	r3, [r0, #0]
  400102:	b903      	cbnz	r3, 400106 <frame_dummy+0x16>
  400104:	bd10      	pop	{r4, pc}
  400106:	4b07      	ldr	r3, [pc, #28]	; (400124 <frame_dummy+0x34>)
  400108:	2b00      	cmp	r3, #0
  40010a:	d0fb      	beq.n	400104 <frame_dummy+0x14>
  40010c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  400110:	4718      	bx	r3
  400112:	bf00      	nop
  400114:	00000000 	.word	0x00000000
  400118:	2000043c 	.word	0x2000043c
  40011c:	00402684 	.word	0x00402684
  400120:	00402684 	.word	0x00402684
  400124:	00000000 	.word	0x00000000

00400128 <local_twi_handler>:
/*
 * For internal use only.
 * A common TWI interrupt handler that is called for all TWI peripherals.
 */
static void local_twi_handler(const portBASE_TYPE twi_index)
{
  400128:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  40012c:	b083      	sub	sp, #12
  40012e:	4607      	mov	r7, r0
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
  400130:	2300      	movs	r3, #0
  400132:	9301      	str	r3, [sp, #4]
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;
  400134:	0103      	lsls	r3, r0, #4
  400136:	4a7d      	ldr	r2, [pc, #500]	; (40032c <local_twi_handler+0x204>)
  400138:	58d5      	ldr	r5, [r2, r3]

	twi_status = twi_get_interrupt_status(twi_port);
  40013a:	4628      	mov	r0, r5
  40013c:	4b7c      	ldr	r3, [pc, #496]	; (400330 <local_twi_handler+0x208>)
  40013e:	4798      	blx	r3
  400140:	4606      	mov	r6, r0
	twi_status &= twi_get_interrupt_mask(twi_port);
  400142:	4628      	mov	r0, r5
  400144:	4b7b      	ldr	r3, [pc, #492]	; (400334 <local_twi_handler+0x20c>)
  400146:	4798      	blx	r3
  400148:	4006      	ands	r6, r0

	/* Has the PDC completed a transmission? */
	if ((twi_status & TWI_SR_ENDTX) != 0UL) {
  40014a:	f416 5f00 	tst.w	r6, #8192	; 0x2000
  40014e:	d04a      	beq.n	4001e6 <local_twi_handler+0xbe>
		/* Disable PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS);
  400150:	4b76      	ldr	r3, [pc, #472]	; (40032c <local_twi_handler+0x204>)
  400152:	eb03 1307 	add.w	r3, r3, r7, lsl #4
  400156:	f44f 7100 	mov.w	r1, #512	; 0x200
  40015a:	6858      	ldr	r0, [r3, #4]
  40015c:	4b76      	ldr	r3, [pc, #472]	; (400338 <local_twi_handler+0x210>)
  40015e:	4798      	blx	r3
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
  400160:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  400164:	4628      	mov	r0, r5
  400166:	4b75      	ldr	r3, [pc, #468]	; (40033c <local_twi_handler+0x214>)
  400168:	4798      	blx	r3

		uint8_t status;
		uint32_t timeout_counter = 0;
  40016a:	2400      	movs	r4, #0

		/* Wait for TX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
  40016c:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_TXRDY) {
  40016e:	f013 0f04 	tst.w	r3, #4
  400172:	d106      	bne.n	400182 <local_twi_handler+0x5a>
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  400174:	3401      	adds	r4, #1
  400176:	f1b4 3fff 	cmp.w	r4, #4294967295
  40017a:	d1f7      	bne.n	40016c <local_twi_handler+0x44>
				transfer_timeout = true;
  40017c:	f04f 0801 	mov.w	r8, #1
  400180:	e001      	b.n	400186 <local_twi_handler+0x5e>
static void local_twi_handler(const portBASE_TYPE twi_index)
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;
  400182:	f04f 0800 	mov.w	r8, #0
				transfer_timeout = true;
				break;
			}
		}
		/* Complete the transfer - stop and last byte */
		twi_port->TWI_CR = TWI_CR_STOP;
  400186:	2302      	movs	r3, #2
  400188:	602b      	str	r3, [r5, #0]
		twi_port->TWI_THR = twis[twi_index].buffer[twis[twi_index].length-1];
  40018a:	4b6d      	ldr	r3, [pc, #436]	; (400340 <local_twi_handler+0x218>)
  40018c:	eb03 01c7 	add.w	r1, r3, r7, lsl #3
  400190:	f853 2037 	ldr.w	r2, [r3, r7, lsl #3]
  400194:	684b      	ldr	r3, [r1, #4]
  400196:	4413      	add	r3, r2
  400198:	f813 3c01 	ldrb.w	r3, [r3, #-1]
  40019c:	636b      	str	r3, [r5, #52]	; 0x34

		/* Wait for TX complete flag */
		while (1) {
			status = twi_port->TWI_SR;
  40019e:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_TXCOMP) {
  4001a0:	f013 0f01 	tst.w	r3, #1
  4001a4:	d104      	bne.n	4001b0 <local_twi_handler+0x88>
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  4001a6:	3401      	adds	r4, #1
  4001a8:	f1b4 3fff 	cmp.w	r4, #4294967295
  4001ac:	d1f7      	bne.n	40019e <local_twi_handler+0x76>
  4001ae:	e09f      	b.n	4002f0 <local_twi_handler+0x1c8>
				break;
			}
		}
		/* If the driver is supporting multi-threading, then return the access
		mutex. */
		if (tx_dma_control[twi_index].peripheral_access_sem != NULL) {
  4001b0:	4b64      	ldr	r3, [pc, #400]	; (400344 <local_twi_handler+0x21c>)
  4001b2:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
  4001b6:	6858      	ldr	r0, [r3, #4]
  4001b8:	b910      	cbnz	r0, 4001c0 <local_twi_handler+0x98>
  4001ba:	e007      	b.n	4001cc <local_twi_handler+0xa4>
			if (status & TWI_SR_TXCOMP) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				transfer_timeout = true;
  4001bc:	f04f 0801 	mov.w	r8, #1
			}
		}
		/* If the driver is supporting multi-threading, then return the access
		mutex. */
		if (tx_dma_control[twi_index].peripheral_access_sem != NULL) {
			xSemaphoreGiveFromISR(
  4001c0:	2300      	movs	r3, #0
  4001c2:	aa01      	add	r2, sp, #4
  4001c4:	4619      	mov	r1, r3
  4001c6:	f8df 9180 	ldr.w	r9, [pc, #384]	; 400348 <local_twi_handler+0x220>
  4001ca:	47c8      	blx	r9
					&higher_priority_task_woken);
		}

		/* if the sending task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
  4001cc:	f1b4 3fff 	cmp.w	r4, #4294967295
  4001d0:	d00b      	beq.n	4001ea <local_twi_handler+0xc2>
			if (tx_dma_control[twi_index]. transaction_complete_notification_semaphore != NULL) {
  4001d2:	4b5c      	ldr	r3, [pc, #368]	; (400344 <local_twi_handler+0x21c>)
  4001d4:	f853 0037 	ldr.w	r0, [r3, r7, lsl #3]
  4001d8:	b138      	cbz	r0, 4001ea <local_twi_handler+0xc2>
				xSemaphoreGiveFromISR(
  4001da:	2300      	movs	r3, #0
  4001dc:	aa01      	add	r2, sp, #4
  4001de:	4619      	mov	r1, r3
  4001e0:	4c59      	ldr	r4, [pc, #356]	; (400348 <local_twi_handler+0x220>)
  4001e2:	47a0      	blx	r4
  4001e4:	e001      	b.n	4001ea <local_twi_handler+0xc2>
static void local_twi_handler(const portBASE_TYPE twi_index)
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;
  4001e6:	f04f 0800 	mov.w	r8, #0
			}
		}
	}

	/* Has the PDC completed a reception? */
	if ((twi_status & TWI_SR_ENDRX) != 0UL) {
  4001ea:	f416 5f80 	tst.w	r6, #4096	; 0x1000
  4001ee:	d054      	beq.n	40029a <local_twi_handler+0x172>
		uint32_t timeout_counter = 0;
		uint32_t status;
		/* Must handle the two last bytes */
		/* Disable PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_RXTDIS);
  4001f0:	4b4e      	ldr	r3, [pc, #312]	; (40032c <local_twi_handler+0x204>)
  4001f2:	eb03 1307 	add.w	r3, r3, r7, lsl #4
  4001f6:	2102      	movs	r1, #2
  4001f8:	6858      	ldr	r0, [r3, #4]
  4001fa:	4b4f      	ldr	r3, [pc, #316]	; (400338 <local_twi_handler+0x210>)
  4001fc:	4798      	blx	r3

		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);
  4001fe:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  400202:	4628      	mov	r0, r5
  400204:	4b4d      	ldr	r3, [pc, #308]	; (40033c <local_twi_handler+0x214>)
  400206:	4798      	blx	r3
		}
	}

	/* Has the PDC completed a reception? */
	if ((twi_status & TWI_SR_ENDRX) != 0UL) {
		uint32_t timeout_counter = 0;
  400208:	2400      	movs	r4, #0

		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);

		/* Wait for RX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
  40020a:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_RXRDY) {
  40020c:	f013 0f02 	tst.w	r3, #2
  400210:	d103      	bne.n	40021a <local_twi_handler+0xf2>
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  400212:	3401      	adds	r4, #1
  400214:	f1b4 3fff 	cmp.w	r4, #4294967295
  400218:	d1f7      	bne.n	40020a <local_twi_handler+0xe2>
				break;
			}
		}
		/* Complete the transfer. */
		twi_port->TWI_CR = TWI_CR_STOP;
  40021a:	2302      	movs	r3, #2
  40021c:	602b      	str	r3, [r5, #0]
		/* Read second last data */
		twis[twi_index].buffer[(twis[twi_index].length)-2] = twi_port->TWI_RHR;
  40021e:	4b48      	ldr	r3, [pc, #288]	; (400340 <local_twi_handler+0x218>)
  400220:	f853 1037 	ldr.w	r1, [r3, r7, lsl #3]
  400224:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
  400228:	685a      	ldr	r2, [r3, #4]
  40022a:	6b28      	ldr	r0, [r5, #48]	; 0x30
  40022c:	188b      	adds	r3, r1, r2
  40022e:	f803 0c02 	strb.w	r0, [r3, #-2]

		/* Wait for RX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
  400232:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_RXRDY) {
  400234:	f013 0f02 	tst.w	r3, #2
  400238:	d104      	bne.n	400244 <local_twi_handler+0x11c>
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  40023a:	3401      	adds	r4, #1
  40023c:	f1b4 3fff 	cmp.w	r4, #4294967295
  400240:	d1f7      	bne.n	400232 <local_twi_handler+0x10a>
  400242:	e068      	b.n	400316 <local_twi_handler+0x1ee>
				break;
			}
		}

		if (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
  400244:	f1b4 3fff 	cmp.w	r4, #4294967295
  400248:	d05e      	beq.n	400308 <local_twi_handler+0x1e0>
			/* Read last data */
			twis[twi_index].buffer[(twis[twi_index].length)-1] = twi_port->TWI_RHR;
  40024a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  40024c:	440a      	add	r2, r1
  40024e:	f802 3c01 	strb.w	r3, [r2, #-1]
			timeout_counter = 0;
  400252:	2400      	movs	r4, #0
			/* Wait for TX complete flag before releasing semaphore */
			while (1) {
				status = twi_port->TWI_SR;
  400254:	6a2b      	ldr	r3, [r5, #32]
				if (status & TWI_SR_TXCOMP) {
  400256:	f013 0f01 	tst.w	r3, #1
  40025a:	d104      	bne.n	400266 <local_twi_handler+0x13e>
					break;
				}
				/* Check timeout condition. */
				if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  40025c:	3401      	adds	r4, #1
  40025e:	f1b4 3fff 	cmp.w	r4, #4294967295
  400262:	d1f7      	bne.n	400254 <local_twi_handler+0x12c>
  400264:	e04e      	b.n	400304 <local_twi_handler+0x1dc>
		}

		/* If the driver is supporting multi-threading, then return the access
		mutex.  NOTE: As the peripheral is half duplex there is only one
		access mutex, and the reception uses the tx access muted. */
		if (tx_dma_control[twi_index].peripheral_access_sem != NULL) {
  400266:	4b37      	ldr	r3, [pc, #220]	; (400344 <local_twi_handler+0x21c>)
  400268:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
  40026c:	6858      	ldr	r0, [r3, #4]
  40026e:	b910      	cbnz	r0, 400276 <local_twi_handler+0x14e>
  400270:	e007      	b.n	400282 <local_twi_handler+0x15a>
  400272:	f04f 34ff 	mov.w	r4, #4294967295
			xSemaphoreGiveFromISR(
  400276:	2300      	movs	r3, #0
  400278:	aa01      	add	r2, sp, #4
  40027a:	4619      	mov	r1, r3
  40027c:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 400348 <local_twi_handler+0x220>
  400280:	47c8      	blx	r9
					&higher_priority_task_woken);
		}

		/* if the receiving task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if  (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
  400282:	f1b4 3fff 	cmp.w	r4, #4294967295
  400286:	d008      	beq.n	40029a <local_twi_handler+0x172>
			if (rx_dma_control[twi_index].transaction_complete_notification_semaphore != NULL) {
  400288:	4b30      	ldr	r3, [pc, #192]	; (40034c <local_twi_handler+0x224>)
  40028a:	f853 0037 	ldr.w	r0, [r3, r7, lsl #3]
  40028e:	b120      	cbz	r0, 40029a <local_twi_handler+0x172>
				xSemaphoreGiveFromISR(
  400290:	2300      	movs	r3, #0
  400292:	aa01      	add	r2, sp, #4
  400294:	4619      	mov	r1, r3
  400296:	4c2c      	ldr	r4, [pc, #176]	; (400348 <local_twi_handler+0x220>)
  400298:	47a0      	blx	r4
						&higher_priority_task_woken);
			}
		}
	}

	if (((twi_status & SR_ERROR_INTERRUPTS) != 0) || (transfer_timeout == true)) {
  40029a:	f416 7f50 	tst.w	r6, #832	; 0x340
  40029e:	d102      	bne.n	4002a6 <local_twi_handler+0x17e>
  4002a0:	f1b8 0f00 	cmp.w	r8, #0
  4002a4:	d01f      	beq.n	4002e6 <local_twi_handler+0x1be>
		Stop the transmission, disable interrupts used by the peripheral, and
		ensure the peripheral access mutex is made available to tasks.  As this
		peripheral is half duplex, only the Tx peripheral access mutex exits.*/

		/* Stop the PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS | PERIPH_PTCR_RXTDIS);
  4002a6:	4b21      	ldr	r3, [pc, #132]	; (40032c <local_twi_handler+0x204>)
  4002a8:	eb03 1307 	add.w	r3, r3, r7, lsl #4
  4002ac:	f240 2102 	movw	r1, #514	; 0x202
  4002b0:	6858      	ldr	r0, [r3, #4]
  4002b2:	4b21      	ldr	r3, [pc, #132]	; (400338 <local_twi_handler+0x210>)
  4002b4:	4798      	blx	r3

		if (!(twi_status & TWI_SR_NACK)) {
  4002b6:	f416 7f80 	tst.w	r6, #256	; 0x100
			/* Do not send stop if NACK received. Handled by hardware */
			twi_port->TWI_CR = TWI_CR_STOP;
  4002ba:	bf04      	itt	eq
  4002bc:	2302      	moveq	r3, #2
  4002be:	602b      	streq	r3, [r5, #0]
		}
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
  4002c0:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  4002c4:	4628      	mov	r0, r5
  4002c6:	4c1d      	ldr	r4, [pc, #116]	; (40033c <local_twi_handler+0x214>)
  4002c8:	47a0      	blx	r4
		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);
  4002ca:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  4002ce:	4628      	mov	r0, r5
  4002d0:	47a0      	blx	r4

		if (tx_dma_control[twi_index].peripheral_access_sem != NULL) {
  4002d2:	4b1c      	ldr	r3, [pc, #112]	; (400344 <local_twi_handler+0x21c>)
  4002d4:	eb03 07c7 	add.w	r7, r3, r7, lsl #3
  4002d8:	6878      	ldr	r0, [r7, #4]
  4002da:	b120      	cbz	r0, 4002e6 <local_twi_handler+0x1be>
			xSemaphoreGiveFromISR(
  4002dc:	2300      	movs	r3, #0
  4002de:	aa01      	add	r2, sp, #4
  4002e0:	4619      	mov	r1, r3
  4002e2:	4c19      	ldr	r4, [pc, #100]	; (400348 <local_twi_handler+0x220>)
  4002e4:	47a0      	blx	r4
	has a priority equal to or higher than the currently running task (the task
	this ISR interrupted), then higher_priority_task_woken will have
	automatically been set to pdTRUE within the semaphore function.
	portEND_SWITCHING_ISR() will then ensure that this ISR returns directly to
	the higher priority unblocked task. */
	portEND_SWITCHING_ISR(higher_priority_task_woken);
  4002e6:	9b01      	ldr	r3, [sp, #4]
  4002e8:	b1e3      	cbz	r3, 400324 <local_twi_handler+0x1fc>
  4002ea:	4b19      	ldr	r3, [pc, #100]	; (400350 <local_twi_handler+0x228>)
  4002ec:	4798      	blx	r3
}
  4002ee:	e019      	b.n	400324 <local_twi_handler+0x1fc>
				break;
			}
		}
		/* If the driver is supporting multi-threading, then return the access
		mutex. */
		if (tx_dma_control[twi_index].peripheral_access_sem != NULL) {
  4002f0:	4b14      	ldr	r3, [pc, #80]	; (400344 <local_twi_handler+0x21c>)
  4002f2:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
  4002f6:	6858      	ldr	r0, [r3, #4]
  4002f8:	2800      	cmp	r0, #0
  4002fa:	f47f af5f 	bne.w	4001bc <local_twi_handler+0x94>
			if (status & TWI_SR_TXCOMP) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				transfer_timeout = true;
  4002fe:	f04f 0801 	mov.w	r8, #1
  400302:	e772      	b.n	4001ea <local_twi_handler+0xc2>
				if (status & TWI_SR_TXCOMP) {
					break;
				}
				/* Check timeout condition. */
				if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
					transfer_timeout = true;
  400304:	f04f 0801 	mov.w	r8, #1
		}

		/* If the driver is supporting multi-threading, then return the access
		mutex.  NOTE: As the peripheral is half duplex there is only one
		access mutex, and the reception uses the tx access muted. */
		if (tx_dma_control[twi_index].peripheral_access_sem != NULL) {
  400308:	4b0e      	ldr	r3, [pc, #56]	; (400344 <local_twi_handler+0x21c>)
  40030a:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
  40030e:	6858      	ldr	r0, [r3, #4]
  400310:	2800      	cmp	r0, #0
  400312:	d1ae      	bne.n	400272 <local_twi_handler+0x14a>
  400314:	e7c1      	b.n	40029a <local_twi_handler+0x172>
  400316:	4b0b      	ldr	r3, [pc, #44]	; (400344 <local_twi_handler+0x21c>)
  400318:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
  40031c:	6858      	ldr	r0, [r3, #4]
  40031e:	2800      	cmp	r0, #0
  400320:	d1a9      	bne.n	400276 <local_twi_handler+0x14e>
  400322:	e7ba      	b.n	40029a <local_twi_handler+0x172>
	this ISR interrupted), then higher_priority_task_woken will have
	automatically been set to pdTRUE within the semaphore function.
	portEND_SWITCHING_ISR() will then ensure that this ISR returns directly to
	the higher priority unblocked task. */
	portEND_SWITCHING_ISR(higher_priority_task_woken);
}
  400324:	b003      	add	sp, #12
  400326:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  40032a:	bf00      	nop
  40032c:	00402600 	.word	0x00402600
  400330:	004005e9 	.word	0x004005e9
  400334:	004005ed 	.word	0x004005ed
  400338:	004005d1 	.word	0x004005d1
  40033c:	004005e1 	.word	0x004005e1
  400340:	20000464 	.word	0x20000464
  400344:	20000474 	.word	0x20000474
  400348:	00401311 	.word	0x00401311
  40034c:	20000454 	.word	0x20000454
  400350:	00400d91 	.word	0x00400d91

00400354 <TWI0_Handler>:
#endif /* TWI */

#ifdef TWI0

void TWI0_Handler(void)
{
  400354:	b508      	push	{r3, lr}
	local_twi_handler(0);
  400356:	2000      	movs	r0, #0
  400358:	4b01      	ldr	r3, [pc, #4]	; (400360 <TWI0_Handler+0xc>)
  40035a:	4798      	blx	r3
  40035c:	bd08      	pop	{r3, pc}
  40035e:	bf00      	nop
  400360:	00400129 	.word	0x00400129

00400364 <TWI1_Handler>:
#endif

#ifdef TWI1

void TWI1_Handler(void)
{
  400364:	b508      	push	{r3, lr}
	local_twi_handler(1);
  400366:	2001      	movs	r0, #1
  400368:	4b01      	ldr	r3, [pc, #4]	; (400370 <TWI1_Handler+0xc>)
  40036a:	4798      	blx	r3
  40036c:	bd08      	pop	{r3, pc}
  40036e:	bf00      	nop
  400370:	00400129 	.word	0x00400129

00400374 <configure_rx_dma>:
 * For internal use only.
 * Configures the Rx DMA to receive data into free space within the Rx buffer.
 */
static void configure_rx_dma(uint32_t uart_index,
		enum buffer_operations operation_performed)
{
  400374:	b570      	push	{r4, r5, r6, lr}
	rx_buffer_definition = &(rx_buffer_definitions[uart_index]);

	/* How much space is there between the start of the DMA buffer and the
	current read pointer?  */

	if (((uint32_t)rx_buffer_definition->next_byte_to_read) ==
  400376:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
  40037a:	4b2d      	ldr	r3, [pc, #180]	; (400430 <configure_rx_dma+0xbc>)
  40037c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  400380:	699a      	ldr	r2, [r3, #24]
			rx_buffer_definition->rx_pdc_parameters.ul_addr) {
  400382:	689b      	ldr	r3, [r3, #8]
	rx_buffer_definition = &(rx_buffer_definitions[uart_index]);

	/* How much space is there between the start of the DMA buffer and the
	current read pointer?  */

	if (((uint32_t)rx_buffer_definition->next_byte_to_read) ==
  400384:	429a      	cmp	r2, r3
  400386:	d114      	bne.n	4003b2 <configure_rx_dma+0x3e>
		/* The read pointer and the write pointer are equal.  If this function
		was called because data was added to the buffer, then there is no free
		space in the buffer remaining.  If this function was called because data
		was removed from the buffer, then the space remaining is from the write
		pointer up to the end of the buffer. */
		if (operation_performed == data_added) {
  400388:	b951      	cbnz	r1, 4003a0 <configure_rx_dma+0x2c>
			rx_buffer_definition->rx_pdc_parameters.ul_size = 0UL;
  40038a:	ebc0 01c0 	rsb	r1, r0, r0, lsl #3
  40038e:	4b28      	ldr	r3, [pc, #160]	; (400430 <configure_rx_dma+0xbc>)
  400390:	eb03 0381 	add.w	r3, r3, r1, lsl #2
  400394:	2100      	movs	r1, #0
  400396:	60d9      	str	r1, [r3, #12]
		available is up to the end of the buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
			rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	}

	configASSERT((rx_buffer_definition->rx_pdc_parameters.ul_addr+
  400398:	685b      	ldr	r3, [r3, #4]
  40039a:	429a      	cmp	r2, r3
  40039c:	d941      	bls.n	400422 <configure_rx_dma+0xae>
  40039e:	e024      	b.n	4003ea <configure_rx_dma+0x76>
		was removed from the buffer, then the space remaining is from the write
		pointer up to the end of the buffer. */
		if (operation_performed == data_added) {
			rx_buffer_definition->rx_pdc_parameters.ul_size = 0UL;
		} else {
			rx_buffer_definition->rx_pdc_parameters.ul_size =
  4003a0:	ebc0 04c0 	rsb	r4, r0, r0, lsl #3
  4003a4:	4922      	ldr	r1, [pc, #136]	; (400430 <configure_rx_dma+0xbc>)
  4003a6:	eb01 0184 	add.w	r1, r1, r4, lsl #2
  4003aa:	684c      	ldr	r4, [r1, #4]
  4003ac:	1aa2      	subs	r2, r4, r2
  4003ae:	60ca      	str	r2, [r1, #12]
  4003b0:	e011      	b.n	4003d6 <configure_rx_dma+0x62>
				rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
		}
	} else if (((uint32_t)rx_buffer_definition->next_byte_to_read) >
  4003b2:	429a      	cmp	r2, r3
  4003b4:	d907      	bls.n	4003c6 <configure_rx_dma+0x52>
			rx_buffer_definition->rx_pdc_parameters.ul_addr) {
		/* The read pointer is ahead of the write pointer.  The space available
		is up to the write pointer to ensure unread data is not overwritten. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
  4003b6:	ebc0 04c0 	rsb	r4, r0, r0, lsl #3
  4003ba:	491d      	ldr	r1, [pc, #116]	; (400430 <configure_rx_dma+0xbc>)
  4003bc:	eb01 0184 	add.w	r1, r1, r4, lsl #2
  4003c0:	1ad2      	subs	r2, r2, r3
  4003c2:	60ca      	str	r2, [r1, #12]
  4003c4:	e007      	b.n	4003d6 <configure_rx_dma+0x62>
			((uint32_t) rx_buffer_definition->next_byte_to_read) - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	} else {
		/* The write pointer is ahead of the read pointer so the space
		available is up to the end of the buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
  4003c6:	ebc0 01c0 	rsb	r1, r0, r0, lsl #3
  4003ca:	4a19      	ldr	r2, [pc, #100]	; (400430 <configure_rx_dma+0xbc>)
  4003cc:	eb02 0281 	add.w	r2, r2, r1, lsl #2
  4003d0:	6851      	ldr	r1, [r2, #4]
  4003d2:	1ac9      	subs	r1, r1, r3
  4003d4:	60d1      	str	r1, [r2, #12]
			rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	}

	configASSERT((rx_buffer_definition->rx_pdc_parameters.ul_addr+
  4003d6:	ebc0 01c0 	rsb	r1, r0, r0, lsl #3
  4003da:	4a15      	ldr	r2, [pc, #84]	; (400430 <configure_rx_dma+0xbc>)
  4003dc:	eb02 0281 	add.w	r2, r2, r1, lsl #2
  4003e0:	68d1      	ldr	r1, [r2, #12]
  4003e2:	440b      	add	r3, r1
  4003e4:	6852      	ldr	r2, [r2, #4]
  4003e6:	4293      	cmp	r3, r2
  4003e8:	d903      	bls.n	4003f2 <configure_rx_dma+0x7e>
  4003ea:	4b12      	ldr	r3, [pc, #72]	; (400434 <configure_rx_dma+0xc0>)
  4003ec:	4798      	blx	r3
  4003ee:	bf00      	nop
  4003f0:	e7fd      	b.n	4003ee <configure_rx_dma+0x7a>
			rx_buffer_definition->rx_pdc_parameters.ul_size) <=
			rx_buffer_definition->past_rx_buffer_end_address);

	if (rx_buffer_definition->rx_pdc_parameters.ul_size > 0) {
  4003f2:	b1b1      	cbz	r1, 400422 <configure_rx_dma+0xae>
		/* Restart the DMA to receive into whichever space was calculated
		as remaining.  First clear any characters that might already be in the
		registers. */
		pdc_rx_init(
  4003f4:	4d10      	ldr	r5, [pc, #64]	; (400438 <configure_rx_dma+0xc4>)
  4003f6:	0104      	lsls	r4, r0, #4
  4003f8:	192b      	adds	r3, r5, r4
  4003fa:	685e      	ldr	r6, [r3, #4]
  4003fc:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
  400400:	4b0b      	ldr	r3, [pc, #44]	; (400430 <configure_rx_dma+0xbc>)
  400402:	eb03 0180 	add.w	r1, r3, r0, lsl #2
  400406:	2200      	movs	r2, #0
  400408:	3108      	adds	r1, #8
  40040a:	4630      	mov	r0, r6
  40040c:	4b0b      	ldr	r3, [pc, #44]	; (40043c <configure_rx_dma+0xc8>)
  40040e:	4798      	blx	r3
				all_uart_definitions[uart_index].pdc_base_address, &rx_buffer_definition->rx_pdc_parameters,
				NULL);
		pdc_enable_transfer(
  400410:	2101      	movs	r1, #1
  400412:	4630      	mov	r0, r6
  400414:	4b0a      	ldr	r3, [pc, #40]	; (400440 <configure_rx_dma+0xcc>)
  400416:	4798      	blx	r3
				all_uart_definitions[uart_index].pdc_base_address,
				PERIPH_PTCR_RXTEN);
		uart_enable_interrupt(
  400418:	2109      	movs	r1, #9
  40041a:	5928      	ldr	r0, [r5, r4]
  40041c:	4b09      	ldr	r3, [pc, #36]	; (400444 <configure_rx_dma+0xd0>)
  40041e:	4798      	blx	r3
  400420:	bd70      	pop	{r4, r5, r6, pc}
	} else {
		/* The write pointer has reached the read pointer.  There is no
		more room so the DMA is not re-enabled until a read has created
		space. */
		uart_disable_interrupt(
				all_uart_definitions[uart_index].peripheral_base_address,
  400422:	0100      	lsls	r0, r0, #4
				UART_IER_ENDRX | UART_IER_RXRDY);
	} else {
		/* The write pointer has reached the read pointer.  There is no
		more room so the DMA is not re-enabled until a read has created
		space. */
		uart_disable_interrupt(
  400424:	2109      	movs	r1, #9
  400426:	4b04      	ldr	r3, [pc, #16]	; (400438 <configure_rx_dma+0xc4>)
  400428:	5818      	ldr	r0, [r3, r0]
  40042a:	4b07      	ldr	r3, [pc, #28]	; (400448 <configure_rx_dma+0xd4>)
  40042c:	4798      	blx	r3
  40042e:	bd70      	pop	{r4, r5, r6, pc}
  400430:	20000484 	.word	0x20000484
  400434:	00400da1 	.word	0x00400da1
  400438:	00402620 	.word	0x00402620
  40043c:	004005ad 	.word	0x004005ad
  400440:	004005c5 	.word	0x004005c5
  400444:	004005f1 	.word	0x004005f1
  400448:	004005f5 	.word	0x004005f5

0040044c <local_uart_handler>:
/*
 * For internal use only.
 * A common UART interrupt handler that is called for all UART peripherals.
 */
static void local_uart_handler(const portBASE_TYPE uart_index)
{
  40044c:	b5f0      	push	{r4, r5, r6, r7, lr}
  40044e:	b083      	sub	sp, #12
  400450:	4604      	mov	r4, r0
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
  400452:	2300      	movs	r3, #0
  400454:	9301      	str	r3, [sp, #4]
	uint32_t uart_status;
	freertos_pdc_rx_control_t *rx_buffer_definition;

	uart_status = uart_get_status(
			all_uart_definitions[uart_index].peripheral_base_address);
  400456:	0103      	lsls	r3, r0, #4
  400458:	4a41      	ldr	r2, [pc, #260]	; (400560 <local_uart_handler+0x114>)
  40045a:	58d6      	ldr	r6, [r2, r3]
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t uart_status;
	freertos_pdc_rx_control_t *rx_buffer_definition;

	uart_status = uart_get_status(
  40045c:	4630      	mov	r0, r6
  40045e:	4b41      	ldr	r3, [pc, #260]	; (400564 <local_uart_handler+0x118>)
  400460:	4798      	blx	r3
  400462:	4605      	mov	r5, r0
			all_uart_definitions[uart_index].peripheral_base_address);
	uart_status &= uart_get_interrupt_mask(
  400464:	4630      	mov	r0, r6
  400466:	4b40      	ldr	r3, [pc, #256]	; (400568 <local_uart_handler+0x11c>)
  400468:	4798      	blx	r3
  40046a:	4005      	ands	r5, r0
			all_uart_definitions[uart_index].peripheral_base_address);

	rx_buffer_definition = &(rx_buffer_definitions[uart_index]);

	/* Has the PDC completed a transmission? */
	if ((uart_status & UART_SR_ENDTX) != 0UL) {
  40046c:	f015 0f10 	tst.w	r5, #16
  400470:	d016      	beq.n	4004a0 <local_uart_handler+0x54>
		uart_disable_interrupt(
  400472:	2110      	movs	r1, #16
  400474:	4630      	mov	r0, r6
  400476:	4b3d      	ldr	r3, [pc, #244]	; (40056c <local_uart_handler+0x120>)
  400478:	4798      	blx	r3
				all_uart_definitions[uart_index].peripheral_base_address,
				UART_IDR_ENDTX);

		/* If the driver is supporting multi-threading, then return the access
		mutex. */
		if (tx_dma_control[uart_index].peripheral_access_sem != NULL) {
  40047a:	4b3d      	ldr	r3, [pc, #244]	; (400570 <local_uart_handler+0x124>)
  40047c:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
  400480:	6858      	ldr	r0, [r3, #4]
  400482:	b120      	cbz	r0, 40048e <local_uart_handler+0x42>
			xSemaphoreGiveFromISR(
  400484:	2300      	movs	r3, #0
  400486:	aa01      	add	r2, sp, #4
  400488:	4619      	mov	r1, r3
  40048a:	4f3a      	ldr	r7, [pc, #232]	; (400574 <local_uart_handler+0x128>)
  40048c:	47b8      	blx	r7
					&higher_priority_task_woken);
		}

		/* if the sending task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if (tx_dma_control[uart_index].transaction_complete_notification_semaphore != NULL) {
  40048e:	4b38      	ldr	r3, [pc, #224]	; (400570 <local_uart_handler+0x124>)
  400490:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
  400494:	b120      	cbz	r0, 4004a0 <local_uart_handler+0x54>
			xSemaphoreGiveFromISR(
  400496:	2300      	movs	r3, #0
  400498:	aa01      	add	r2, sp, #4
  40049a:	4619      	mov	r1, r3
  40049c:	4f35      	ldr	r7, [pc, #212]	; (400574 <local_uart_handler+0x128>)
  40049e:	47b8      	blx	r7
					tx_dma_control[uart_index].transaction_complete_notification_semaphore,
					&higher_priority_task_woken);
		}
	}

	if ((uart_status & UART_SR_ENDRX) != 0UL) {
  4004a0:	f015 0f08 	tst.w	r5, #8
  4004a4:	d033      	beq.n	40050e <local_uart_handler+0xc2>
		/* It is possible to initialise the peripheral to only use Tx and not Rx.
		Check that Rx has been initialised. */
		configASSERT(rx_buffer_definition->next_byte_to_read);
  4004a6:	ebc4 02c4 	rsb	r2, r4, r4, lsl #3
  4004aa:	4b33      	ldr	r3, [pc, #204]	; (400578 <local_uart_handler+0x12c>)
  4004ac:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  4004b0:	699b      	ldr	r3, [r3, #24]
  4004b2:	b91b      	cbnz	r3, 4004bc <local_uart_handler+0x70>
  4004b4:	4b31      	ldr	r3, [pc, #196]	; (40057c <local_uart_handler+0x130>)
  4004b6:	4798      	blx	r3
  4004b8:	bf00      	nop
  4004ba:	e7fd      	b.n	4004b8 <local_uart_handler+0x6c>
		configASSERT(rx_buffer_definition->next_byte_to_read !=
  4004bc:	2b01      	cmp	r3, #1
  4004be:	d103      	bne.n	4004c8 <local_uart_handler+0x7c>
  4004c0:	4b2e      	ldr	r3, [pc, #184]	; (40057c <local_uart_handler+0x130>)
  4004c2:	4798      	blx	r3
  4004c4:	bf00      	nop
  4004c6:	e7fd      	b.n	4004c4 <local_uart_handler+0x78>
				RX_NOT_USED);

		/* Out of DMA buffer, configure the next buffer.  Start by moving
		the DMA buffer start address up to the end of the previously defined
		buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_addr +=
  4004c8:	ebc4 02c4 	rsb	r2, r4, r4, lsl #3
  4004cc:	4b2a      	ldr	r3, [pc, #168]	; (400578 <local_uart_handler+0x12c>)
  4004ce:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  4004d2:	6899      	ldr	r1, [r3, #8]
  4004d4:	68da      	ldr	r2, [r3, #12]
  4004d6:	440a      	add	r2, r1
  4004d8:	609a      	str	r2, [r3, #8]
				rx_buffer_definition->rx_pdc_parameters.ul_size;

		/* If the end of the buffer has been reached, wrap back to the start. */
		if (rx_buffer_definition->rx_pdc_parameters.ul_addr >=
  4004da:	685b      	ldr	r3, [r3, #4]
  4004dc:	429a      	cmp	r2, r3
  4004de:	d306      	bcc.n	4004ee <local_uart_handler+0xa2>
				rx_buffer_definition->past_rx_buffer_end_address)
		{
			rx_buffer_definition->rx_pdc_parameters.ul_addr =
  4004e0:	4a25      	ldr	r2, [pc, #148]	; (400578 <local_uart_handler+0x12c>)
  4004e2:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  4004e6:	009b      	lsls	r3, r3, #2
  4004e8:	18d1      	adds	r1, r2, r3
  4004ea:	58d3      	ldr	r3, [r2, r3]
  4004ec:	608b      	str	r3, [r1, #8]
					rx_buffer_definition->rx_buffer_start_address;
		}

		/* Reset the Rx DMA to receive data into whatever free space remains in
		the Rx buffer. */
		configure_rx_dma(uart_index, data_added);
  4004ee:	2100      	movs	r1, #0
  4004f0:	4620      	mov	r0, r4
  4004f2:	4b23      	ldr	r3, [pc, #140]	; (400580 <local_uart_handler+0x134>)
  4004f4:	4798      	blx	r3

		if (rx_buffer_definition->rx_event_semaphore != NULL) {
  4004f6:	ebc4 02c4 	rsb	r2, r4, r4, lsl #3
  4004fa:	4b1f      	ldr	r3, [pc, #124]	; (400578 <local_uart_handler+0x12c>)
  4004fc:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  400500:	6918      	ldr	r0, [r3, #16]
  400502:	b338      	cbz	r0, 400554 <local_uart_handler+0x108>
			/* Notify that new data is available. */
			xSemaphoreGiveFromISR(
  400504:	2300      	movs	r3, #0
  400506:	aa01      	add	r2, sp, #4
  400508:	4619      	mov	r1, r3
  40050a:	4f1a      	ldr	r7, [pc, #104]	; (400574 <local_uart_handler+0x128>)
  40050c:	47b8      	blx	r7
	 * It happened only when in PDC mode with TXRDY and RXRDY interrupts since
	 * the flags has been cleared by PDC.
	 * As the TXRDY is never enabled in this service, here we
	 * check the RXRDY interrupt case.
	 */
	if (uart_status == 0UL) {
  40050e:	b965      	cbnz	r5, 40052a <local_uart_handler+0xde>
		/* Character has been placed into the Rx buffer. */
		if (rx_buffer_definition->rx_event_semaphore != NULL) {
  400510:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
  400514:	4b18      	ldr	r3, [pc, #96]	; (400578 <local_uart_handler+0x12c>)
  400516:	eb03 0384 	add.w	r3, r3, r4, lsl #2
  40051a:	6918      	ldr	r0, [r3, #16]
  40051c:	b1a8      	cbz	r0, 40054a <local_uart_handler+0xfe>
			/* Notify that new data is available. */
			xSemaphoreGiveFromISR(
  40051e:	2300      	movs	r3, #0
  400520:	aa01      	add	r2, sp, #4
  400522:	4619      	mov	r1, r3
  400524:	4c13      	ldr	r4, [pc, #76]	; (400574 <local_uart_handler+0x128>)
  400526:	47a0      	blx	r4
  400528:	e00f      	b.n	40054a <local_uart_handler+0xfe>
					rx_buffer_definition->rx_event_semaphore,
					&higher_priority_task_woken);
		}
	}

	if ((uart_status & SR_ERROR_INTERRUPTS) != 0) {
  40052a:	f015 0fe0 	tst.w	r5, #224	; 0xe0
  40052e:	d00c      	beq.n	40054a <local_uart_handler+0xfe>
		/* An error occurred in either a transmission or reception.  Abort, and
		ensure the peripheral access mutex is made available to tasks. */
		uart_reset_status(
  400530:	4630      	mov	r0, r6
  400532:	4b14      	ldr	r3, [pc, #80]	; (400584 <local_uart_handler+0x138>)
  400534:	4798      	blx	r3
				all_uart_definitions[uart_index].peripheral_base_address);
		if (tx_dma_control[uart_index].peripheral_access_sem != NULL) {
  400536:	4b0e      	ldr	r3, [pc, #56]	; (400570 <local_uart_handler+0x124>)
  400538:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
  40053c:	6860      	ldr	r0, [r4, #4]
  40053e:	b120      	cbz	r0, 40054a <local_uart_handler+0xfe>
			xSemaphoreGiveFromISR(
  400540:	2300      	movs	r3, #0
  400542:	aa01      	add	r2, sp, #4
  400544:	4619      	mov	r1, r3
  400546:	4c0b      	ldr	r4, [pc, #44]	; (400574 <local_uart_handler+0x128>)
  400548:	47a0      	blx	r4
	has a priority equal to or higher than the currently running task (the task
	this ISR interrupted), then higher_priority_task_woken will have
	automatically been set to pdTRUE within the semaphore function.
	portEND_SWITCHING_ISR() will then ensure that this ISR returns directly to
	the higher priority unblocked task. */
	portEND_SWITCHING_ISR(higher_priority_task_woken);
  40054a:	9b01      	ldr	r3, [sp, #4]
  40054c:	b12b      	cbz	r3, 40055a <local_uart_handler+0x10e>
  40054e:	4b0e      	ldr	r3, [pc, #56]	; (400588 <local_uart_handler+0x13c>)
  400550:	4798      	blx	r3
}
  400552:	e002      	b.n	40055a <local_uart_handler+0x10e>
	 * It happened only when in PDC mode with TXRDY and RXRDY interrupts since
	 * the flags has been cleared by PDC.
	 * As the TXRDY is never enabled in this service, here we
	 * check the RXRDY interrupt case.
	 */
	if (uart_status == 0UL) {
  400554:	2d00      	cmp	r5, #0
  400556:	d0f8      	beq.n	40054a <local_uart_handler+0xfe>
  400558:	e7e7      	b.n	40052a <local_uart_handler+0xde>
	this ISR interrupted), then higher_priority_task_woken will have
	automatically been set to pdTRUE within the semaphore function.
	portEND_SWITCHING_ISR() will then ensure that this ISR returns directly to
	the higher priority unblocked task. */
	portEND_SWITCHING_ISR(higher_priority_task_woken);
}
  40055a:	b003      	add	sp, #12
  40055c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40055e:	bf00      	nop
  400560:	00402620 	.word	0x00402620
  400564:	004005fd 	.word	0x004005fd
  400568:	004005f9 	.word	0x004005f9
  40056c:	004005f5 	.word	0x004005f5
  400570:	200004bc 	.word	0x200004bc
  400574:	00401311 	.word	0x00401311
  400578:	20000484 	.word	0x20000484
  40057c:	00400da1 	.word	0x00400da1
  400580:	00400375 	.word	0x00400375
  400584:	00400601 	.word	0x00400601
  400588:	00400d91 	.word	0x00400d91

0040058c <UART0_Handler>:
#endif /* UART */

#ifdef UART0

void UART0_Handler(void)
{
  40058c:	b508      	push	{r3, lr}
	local_uart_handler(0);
  40058e:	2000      	movs	r0, #0
  400590:	4b01      	ldr	r3, [pc, #4]	; (400598 <UART0_Handler+0xc>)
  400592:	4798      	blx	r3
  400594:	bd08      	pop	{r3, pc}
  400596:	bf00      	nop
  400598:	0040044d 	.word	0x0040044d

0040059c <UART1_Handler>:
#endif /* UART0 */

#ifdef UART1

void UART1_Handler(void)
{
  40059c:	b508      	push	{r3, lr}
	local_uart_handler(1);
  40059e:	2001      	movs	r0, #1
  4005a0:	4b01      	ldr	r3, [pc, #4]	; (4005a8 <UART1_Handler+0xc>)
  4005a2:	4798      	blx	r3
  4005a4:	bd08      	pop	{r3, pc}
  4005a6:	bf00      	nop
  4005a8:	0040044d 	.word	0x0040044d

004005ac <pdc_rx_init>:
		pdc_packet_t *p_next_packet)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	if (p_packet) {
  4005ac:	460b      	mov	r3, r1
  4005ae:	b119      	cbz	r1, 4005b8 <pdc_rx_init+0xc>
		p_pdc->PERIPH_RPR = p_packet->ul_addr;
  4005b0:	6809      	ldr	r1, [r1, #0]
  4005b2:	6001      	str	r1, [r0, #0]
		p_pdc->PERIPH_RCR = p_packet->ul_size;
  4005b4:	685b      	ldr	r3, [r3, #4]
  4005b6:	6043      	str	r3, [r0, #4]
	}
	if (p_next_packet) {
  4005b8:	b11a      	cbz	r2, 4005c2 <pdc_rx_init+0x16>
		p_pdc->PERIPH_RNPR = p_next_packet->ul_addr;
  4005ba:	6813      	ldr	r3, [r2, #0]
  4005bc:	6103      	str	r3, [r0, #16]
		p_pdc->PERIPH_RNCR = p_next_packet->ul_size;
  4005be:	6853      	ldr	r3, [r2, #4]
  4005c0:	6143      	str	r3, [r0, #20]
  4005c2:	4770      	bx	lr

004005c4 <pdc_enable_transfer>:
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
			ul_controls & (PERIPH_PTCR_RXTEN | PERIPH_PTCR_TXTEN);
  4005c4:	f021 01fe 	bic.w	r1, r1, #254	; 0xfe
  4005c8:	05c9      	lsls	r1, r1, #23
  4005ca:	0dc9      	lsrs	r1, r1, #23
		uint32_t ul_controls)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
  4005cc:	6201      	str	r1, [r0, #32]
  4005ce:	4770      	bx	lr

004005d0 <pdc_disable_transfer>:
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
			ul_controls & (PERIPH_PTCR_RXTDIS | PERIPH_PTCR_TXTDIS);
  4005d0:	f421 71fe 	bic.w	r1, r1, #508	; 0x1fc
  4005d4:	f021 0101 	bic.w	r1, r1, #1
  4005d8:	0589      	lsls	r1, r1, #22
  4005da:	0d89      	lsrs	r1, r1, #22
		uint32_t ul_controls)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
  4005dc:	6201      	str	r1, [r0, #32]
  4005de:	4770      	bx	lr

004005e0 <twi_disable_interrupt>:
 * \param ul_sources Interrupts to be disabled.
 */
void twi_disable_interrupt(Twi *p_twi, uint32_t ul_sources)
{
	/* Disable the specified interrupts */
	p_twi->TWI_IDR = ul_sources;
  4005e0:	6281      	str	r1, [r0, #40]	; 0x28
	/* Dummy read */
	p_twi->TWI_SR;
  4005e2:	6a03      	ldr	r3, [r0, #32]
  4005e4:	4770      	bx	lr
  4005e6:	bf00      	nop

004005e8 <twi_get_interrupt_status>:
 *
 * \retval TWI interrupt status.
 */
uint32_t twi_get_interrupt_status(Twi *p_twi)
{
	return p_twi->TWI_SR;
  4005e8:	6a00      	ldr	r0, [r0, #32]
}
  4005ea:	4770      	bx	lr

004005ec <twi_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t twi_get_interrupt_mask(Twi *p_twi)
{
	return p_twi->TWI_IMR;
  4005ec:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
}
  4005ee:	4770      	bx	lr

004005f0 <uart_enable_interrupt>:
 * \param p_uart Pointer to a UART instance.
 *  \param ul_sources Interrupts to be enabled.
 */
void uart_enable_interrupt(Uart *p_uart, uint32_t ul_sources)
{
	p_uart->UART_IER = ul_sources;
  4005f0:	6081      	str	r1, [r0, #8]
  4005f2:	4770      	bx	lr

004005f4 <uart_disable_interrupt>:
 * \param p_uart Pointer to a UART instance.
 *  \param ul_sources Interrupts to be disabled.
 */
void uart_disable_interrupt(Uart *p_uart, uint32_t ul_sources)
{
	p_uart->UART_IDR = ul_sources;
  4005f4:	60c1      	str	r1, [r0, #12]
  4005f6:	4770      	bx	lr

004005f8 <uart_get_interrupt_mask>:
 *
 *  \return The interrupt mask value.
 */
uint32_t uart_get_interrupt_mask(Uart *p_uart)
{
	return p_uart->UART_IMR;
  4005f8:	6900      	ldr	r0, [r0, #16]
}
  4005fa:	4770      	bx	lr

004005fc <uart_get_status>:
 *
 * \return The current UART status.
 */
uint32_t uart_get_status(Uart *p_uart)
{
	return p_uart->UART_SR;
  4005fc:	6940      	ldr	r0, [r0, #20]
}
  4005fe:	4770      	bx	lr

00400600 <uart_reset_status>:
 *
 * \param p_uart Pointer to a UART instance.
 */
void uart_reset_status(Uart *p_uart)
{
	p_uart->UART_CR = UART_CR_RSTSTA;
  400600:	f44f 7380 	mov.w	r3, #256	; 0x100
  400604:	6003      	str	r3, [r0, #0]
  400606:	4770      	bx	lr

00400608 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  400608:	b510      	push	{r4, lr}
	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  40060a:	480e      	ldr	r0, [pc, #56]	; (400644 <sysclk_init+0x3c>)
  40060c:	4b0e      	ldr	r3, [pc, #56]	; (400648 <sysclk_init+0x40>)
  40060e:	4798      	blx	r3
		pmc_switch_sclk_to_32kxtal(PMC_OSC_BYPASS);
		break;


	case OSC_MAINCK_4M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_4_MHz);
  400610:	2000      	movs	r0, #0
  400612:	4b0e      	ldr	r3, [pc, #56]	; (40064c <sysclk_init+0x44>)
  400614:	4798      	blx	r3
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  400616:	4c0e      	ldr	r4, [pc, #56]	; (400650 <sysclk_init+0x48>)
  400618:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  40061a:	2800      	cmp	r0, #0
  40061c:	d0fc      	beq.n	400618 <sysclk_init+0x10>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  40061e:	4b0d      	ldr	r3, [pc, #52]	; (400654 <sysclk_init+0x4c>)
  400620:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  400622:	4a0d      	ldr	r2, [pc, #52]	; (400658 <sysclk_init+0x50>)
  400624:	4b0d      	ldr	r3, [pc, #52]	; (40065c <sysclk_init+0x54>)
  400626:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		return pmc_is_locked_pllack();
  400628:	4c0d      	ldr	r4, [pc, #52]	; (400660 <sysclk_init+0x58>)
  40062a:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  40062c:	2800      	cmp	r0, #0
  40062e:	d0fc      	beq.n	40062a <sysclk_init+0x22>

		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  400630:	2000      	movs	r0, #0
  400632:	4b0c      	ldr	r3, [pc, #48]	; (400664 <sysclk_init+0x5c>)
  400634:	4798      	blx	r3
		pmc_switch_mck_to_pllbck(CONFIG_SYSCLK_PRES);
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  400636:	4b0c      	ldr	r3, [pc, #48]	; (400668 <sysclk_init+0x60>)
  400638:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  40063a:	4802      	ldr	r0, [pc, #8]	; (400644 <sysclk_init+0x3c>)
  40063c:	4b02      	ldr	r3, [pc, #8]	; (400648 <sysclk_init+0x40>)
  40063e:	4798      	blx	r3
  400640:	bd10      	pop	{r4, pc}
  400642:	bf00      	nop
  400644:	07270e00 	.word	0x07270e00
  400648:	00400c0d 	.word	0x00400c0d
  40064c:	004009c9 	.word	0x004009c9
  400650:	00400a15 	.word	0x00400a15
  400654:	00400a25 	.word	0x00400a25
  400658:	201d3f01 	.word	0x201d3f01
  40065c:	400e0400 	.word	0x400e0400
  400660:	00400a35 	.word	0x00400a35
  400664:	00400961 	.word	0x00400961
  400668:	00400af9 	.word	0x00400af9

0040066c <pio_set_peripheral>:
		const uint32_t ul_mask)
{
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  40066c:	6442      	str	r2, [r0, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  40066e:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
  400672:	d02f      	beq.n	4006d4 <pio_set_peripheral+0x68>
  400674:	d807      	bhi.n	400686 <pio_set_peripheral+0x1a>
  400676:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  40067a:	d014      	beq.n	4006a6 <pio_set_peripheral+0x3a>
  40067c:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  400680:	d01e      	beq.n	4006c0 <pio_set_peripheral+0x54>
  400682:	b939      	cbnz	r1, 400694 <pio_set_peripheral+0x28>
  400684:	4770      	bx	lr
  400686:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  40068a:	d036      	beq.n	4006fa <pio_set_peripheral+0x8e>
  40068c:	d804      	bhi.n	400698 <pio_set_peripheral+0x2c>
  40068e:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
  400692:	d029      	beq.n	4006e8 <pio_set_peripheral+0x7c>
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  400694:	6042      	str	r2, [r0, #4]
  400696:	4770      	bx	lr

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  400698:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  40069c:	d02d      	beq.n	4006fa <pio_set_peripheral+0x8e>
  40069e:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  4006a2:	d02a      	beq.n	4006fa <pio_set_peripheral+0x8e>
  4006a4:	e7f6      	b.n	400694 <pio_set_peripheral+0x28>
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  4006a6:	b410      	push	{r4}
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  4006a8:	6f04      	ldr	r4, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  4006aa:	6f01      	ldr	r1, [r0, #112]	; 0x70
  4006ac:	43d3      	mvns	r3, r2
  4006ae:	4021      	ands	r1, r4
  4006b0:	4019      	ands	r1, r3
  4006b2:	6701      	str	r1, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  4006b4:	6f44      	ldr	r4, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  4006b6:	6f41      	ldr	r1, [r0, #116]	; 0x74
  4006b8:	4021      	ands	r1, r4
  4006ba:	400b      	ands	r3, r1
  4006bc:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  4006be:	e01a      	b.n	4006f6 <pio_set_peripheral+0x8a>
	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  4006c0:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  4006c2:	4313      	orrs	r3, r2
  4006c4:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  4006c6:	6f41      	ldr	r1, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  4006c8:	6f43      	ldr	r3, [r0, #116]	; 0x74
  4006ca:	400b      	ands	r3, r1
  4006cc:	ea23 0302 	bic.w	r3, r3, r2
  4006d0:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  4006d2:	e7df      	b.n	400694 <pio_set_peripheral+0x28>
#if (!SAMG)
	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  4006d4:	6f01      	ldr	r1, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  4006d6:	6f03      	ldr	r3, [r0, #112]	; 0x70
  4006d8:	400b      	ands	r3, r1
  4006da:	ea23 0302 	bic.w	r3, r3, r2
  4006de:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  4006e0:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  4006e2:	4313      	orrs	r3, r2
  4006e4:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  4006e6:	e7d5      	b.n	400694 <pio_set_peripheral+0x28>
	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  4006e8:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  4006ea:	4313      	orrs	r3, r2
  4006ec:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  4006ee:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  4006f0:	4313      	orrs	r3, r2
  4006f2:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  4006f4:	e7ce      	b.n	400694 <pio_set_peripheral+0x28>
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  4006f6:	6042      	str	r2, [r0, #4]
}
  4006f8:	bc10      	pop	{r4}
  4006fa:	4770      	bx	lr

004006fc <pio_set_input>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  4006fc:	6441      	str	r1, [r0, #68]	; 0x44
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  4006fe:	f012 0f01 	tst.w	r2, #1
		p_pio->PIO_PUER = ul_mask;
  400702:	bf14      	ite	ne
  400704:	6641      	strne	r1, [r0, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  400706:	6601      	streq	r1, [r0, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  400708:	f012 0f0a 	tst.w	r2, #10
		p_pio->PIO_IFER = ul_mask;
  40070c:	bf14      	ite	ne
  40070e:	6201      	strne	r1, [r0, #32]
	} else {
		p_pio->PIO_IFDR = ul_mask;
  400710:	6241      	streq	r1, [r0, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  400712:	f012 0f02 	tst.w	r2, #2
  400716:	d002      	beq.n	40071e <pio_set_input+0x22>
		p_pio->PIO_IFSCDR = ul_mask;
  400718:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
  40071c:	e004      	b.n	400728 <pio_set_input+0x2c>
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  40071e:	f012 0f08 	tst.w	r2, #8
			p_pio->PIO_IFSCER = ul_mask;
  400722:	bf18      	it	ne
  400724:	f8c0 1084 	strne.w	r1, [r0, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  400728:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
  40072a:	6001      	str	r1, [r0, #0]
  40072c:	4770      	bx	lr
  40072e:	bf00      	nop

00400730 <pio_set_output>:
 */
void pio_set_output(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_default_level,
		const uint32_t ul_multidrive_enable,
		const uint32_t ul_pull_up_enable)
{
  400730:	b410      	push	{r4}
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  400732:	6441      	str	r1, [r0, #68]	; 0x44
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  400734:	9c01      	ldr	r4, [sp, #4]
  400736:	b10c      	cbz	r4, 40073c <pio_set_output+0xc>
		p_pio->PIO_PUER = ul_mask;
  400738:	6641      	str	r1, [r0, #100]	; 0x64
  40073a:	e000      	b.n	40073e <pio_set_output+0xe>
	} else {
		p_pio->PIO_PUDR = ul_mask;
  40073c:	6601      	str	r1, [r0, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  40073e:	b10b      	cbz	r3, 400744 <pio_set_output+0x14>
		p_pio->PIO_MDER = ul_mask;
  400740:	6501      	str	r1, [r0, #80]	; 0x50
  400742:	e000      	b.n	400746 <pio_set_output+0x16>
	} else {
		p_pio->PIO_MDDR = ul_mask;
  400744:	6541      	str	r1, [r0, #84]	; 0x54
	}

	/* Set default value */
	if (ul_default_level) {
  400746:	b10a      	cbz	r2, 40074c <pio_set_output+0x1c>
		p_pio->PIO_SODR = ul_mask;
  400748:	6301      	str	r1, [r0, #48]	; 0x30
  40074a:	e000      	b.n	40074e <pio_set_output+0x1e>
	} else {
		p_pio->PIO_CODR = ul_mask;
  40074c:	6341      	str	r1, [r0, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  40074e:	6101      	str	r1, [r0, #16]
	p_pio->PIO_PER = ul_mask;
  400750:	6001      	str	r1, [r0, #0]
}
  400752:	bc10      	pop	{r4}
  400754:	4770      	bx	lr
  400756:	bf00      	nop

00400758 <pio_get_interrupt_status>:
 *
 * \return The interrupt status value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
  400758:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
  40075a:	4770      	bx	lr

0040075c <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
  40075c:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
  40075e:	4770      	bx	lr

00400760 <pio_set_pin_high>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  400760:	0943      	lsrs	r3, r0, #5
  400762:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  400766:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40076a:	025b      	lsls	r3, r3, #9
void pio_set_pin_high(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Value to be driven on the I/O line: 1. */
	p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  40076c:	f000 001f 	and.w	r0, r0, #31
  400770:	2201      	movs	r2, #1
  400772:	fa02 f000 	lsl.w	r0, r2, r0
  400776:	6318      	str	r0, [r3, #48]	; 0x30
  400778:	4770      	bx	lr
  40077a:	bf00      	nop

0040077c <pio_set_pin_low>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40077c:	0943      	lsrs	r3, r0, #5
  40077e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  400782:	f203 7307 	addw	r3, r3, #1799	; 0x707
  400786:	025b      	lsls	r3, r3, #9
void pio_set_pin_low(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Value to be driven on the I/O line: 0. */
	p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  400788:	f000 001f 	and.w	r0, r0, #31
  40078c:	2201      	movs	r2, #1
  40078e:	fa02 f000 	lsl.w	r0, r2, r0
  400792:	6358      	str	r0, [r3, #52]	; 0x34
  400794:	4770      	bx	lr
  400796:	bf00      	nop

00400798 <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  400798:	b570      	push	{r4, r5, r6, lr}
  40079a:	b082      	sub	sp, #8
  40079c:	460d      	mov	r5, r1
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40079e:	0943      	lsrs	r3, r0, #5
  4007a0:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4007a4:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4007a8:	025c      	lsls	r4, r3, #9
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  4007aa:	f001 43f0 	and.w	r3, r1, #2013265920	; 0x78000000
  4007ae:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  4007b2:	d047      	beq.n	400844 <pio_configure_pin+0xac>
  4007b4:	d809      	bhi.n	4007ca <pio_configure_pin+0x32>
  4007b6:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  4007ba:	d021      	beq.n	400800 <pio_configure_pin+0x68>
  4007bc:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  4007c0:	d02f      	beq.n	400822 <pio_configure_pin+0x8a>
  4007c2:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  4007c6:	d16f      	bne.n	4008a8 <pio_configure_pin+0x110>
  4007c8:	e009      	b.n	4007de <pio_configure_pin+0x46>
  4007ca:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  4007ce:	d055      	beq.n	40087c <pio_configure_pin+0xe4>
  4007d0:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  4007d4:	d052      	beq.n	40087c <pio_configure_pin+0xe4>
  4007d6:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  4007da:	d044      	beq.n	400866 <pio_configure_pin+0xce>
  4007dc:	e064      	b.n	4008a8 <pio_configure_pin+0x110>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
  4007de:	f000 001f 	and.w	r0, r0, #31
  4007e2:	2601      	movs	r6, #1
  4007e4:	4086      	lsls	r6, r0
  4007e6:	4632      	mov	r2, r6
  4007e8:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  4007ec:	4620      	mov	r0, r4
  4007ee:	4b30      	ldr	r3, [pc, #192]	; (4008b0 <pio_configure_pin+0x118>)
  4007f0:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  4007f2:	f015 0f01 	tst.w	r5, #1
		p_pio->PIO_PUER = ul_mask;
  4007f6:	bf14      	ite	ne
  4007f8:	6666      	strne	r6, [r4, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  4007fa:	6626      	streq	r6, [r4, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
  4007fc:	2001      	movs	r0, #1
  4007fe:	e054      	b.n	4008aa <pio_configure_pin+0x112>
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, (1 << (ul_pin & 0x1F)));
  400800:	f000 001f 	and.w	r0, r0, #31
  400804:	2601      	movs	r6, #1
  400806:	4086      	lsls	r6, r0
  400808:	4632      	mov	r2, r6
  40080a:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  40080e:	4620      	mov	r0, r4
  400810:	4b27      	ldr	r3, [pc, #156]	; (4008b0 <pio_configure_pin+0x118>)
  400812:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  400814:	f015 0f01 	tst.w	r5, #1
		p_pio->PIO_PUER = ul_mask;
  400818:	bf14      	ite	ne
  40081a:	6666      	strne	r6, [r4, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  40081c:	6626      	streq	r6, [r4, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
  40081e:	2001      	movs	r0, #1
  400820:	e043      	b.n	4008aa <pio_configure_pin+0x112>
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
  400822:	f000 001f 	and.w	r0, r0, #31
  400826:	2601      	movs	r6, #1
  400828:	4086      	lsls	r6, r0
  40082a:	4632      	mov	r2, r6
  40082c:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  400830:	4620      	mov	r0, r4
  400832:	4b1f      	ldr	r3, [pc, #124]	; (4008b0 <pio_configure_pin+0x118>)
  400834:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  400836:	f015 0f01 	tst.w	r5, #1
		p_pio->PIO_PUER = ul_mask;
  40083a:	bf14      	ite	ne
  40083c:	6666      	strne	r6, [r4, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  40083e:	6626      	streq	r6, [r4, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
  400840:	2001      	movs	r0, #1
  400842:	e032      	b.n	4008aa <pio_configure_pin+0x112>
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
  400844:	f000 001f 	and.w	r0, r0, #31
  400848:	2601      	movs	r6, #1
  40084a:	4086      	lsls	r6, r0
  40084c:	4632      	mov	r2, r6
  40084e:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  400852:	4620      	mov	r0, r4
  400854:	4b16      	ldr	r3, [pc, #88]	; (4008b0 <pio_configure_pin+0x118>)
  400856:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  400858:	f015 0f01 	tst.w	r5, #1
		p_pio->PIO_PUER = ul_mask;
  40085c:	bf14      	ite	ne
  40085e:	6666      	strne	r6, [r4, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  400860:	6626      	streq	r6, [r4, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
  400862:	2001      	movs	r0, #1
  400864:	e021      	b.n	4008aa <pio_configure_pin+0x112>
				(ul_flags & PIO_PULLUP));
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
  400866:	f000 011f 	and.w	r1, r0, #31
  40086a:	2601      	movs	r6, #1
  40086c:	462a      	mov	r2, r5
  40086e:	fa06 f101 	lsl.w	r1, r6, r1
  400872:	4620      	mov	r0, r4
  400874:	4b0f      	ldr	r3, [pc, #60]	; (4008b4 <pio_configure_pin+0x11c>)
  400876:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  400878:	4630      	mov	r0, r6
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;
  40087a:	e016      	b.n	4008aa <pio_configure_pin+0x112>

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  40087c:	f005 5260 	and.w	r2, r5, #939524096	; 0x38000000
  400880:	f000 011f 	and.w	r1, r0, #31
  400884:	2601      	movs	r6, #1
  400886:	ea05 0306 	and.w	r3, r5, r6
  40088a:	9300      	str	r3, [sp, #0]
  40088c:	f3c5 0380 	ubfx	r3, r5, #2, #1
  400890:	f1b2 5f60 	cmp.w	r2, #939524096	; 0x38000000
  400894:	bf14      	ite	ne
  400896:	2200      	movne	r2, #0
  400898:	2201      	moveq	r2, #1
  40089a:	fa06 f101 	lsl.w	r1, r6, r1
  40089e:	4620      	mov	r0, r4
  4008a0:	4c05      	ldr	r4, [pc, #20]	; (4008b8 <pio_configure_pin+0x120>)
  4008a2:	47a0      	blx	r4

	default:
		return 0;
	}

	return 1;
  4008a4:	4630      	mov	r0, r6
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;
  4008a6:	e000      	b.n	4008aa <pio_configure_pin+0x112>

	default:
		return 0;
  4008a8:	2000      	movs	r0, #0
	}

	return 1;
}
  4008aa:	b002      	add	sp, #8
  4008ac:	bd70      	pop	{r4, r5, r6, pc}
  4008ae:	bf00      	nop
  4008b0:	0040066d 	.word	0x0040066d
  4008b4:	004006fd 	.word	0x004006fd
  4008b8:	00400731 	.word	0x00400731

004008bc <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  4008bc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  4008c0:	4681      	mov	r9, r0
  4008c2:	4688      	mov	r8, r1
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  4008c4:	4b12      	ldr	r3, [pc, #72]	; (400910 <pio_handler_process+0x54>)
  4008c6:	4798      	blx	r3
  4008c8:	4605      	mov	r5, r0
	status &= pio_get_interrupt_mask(p_pio);
  4008ca:	4648      	mov	r0, r9
  4008cc:	4b11      	ldr	r3, [pc, #68]	; (400914 <pio_handler_process+0x58>)
  4008ce:	4798      	blx	r3

	/* Check pending events */
	if (status != 0) {
  4008d0:	4005      	ands	r5, r0
  4008d2:	d013      	beq.n	4008fc <pio_handler_process+0x40>
  4008d4:	4c10      	ldr	r4, [pc, #64]	; (400918 <pio_handler_process+0x5c>)
  4008d6:	f104 0660 	add.w	r6, r4, #96	; 0x60
		/* Find triggering source */
		i = 0;
		while (status != 0) {
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  4008da:	6823      	ldr	r3, [r4, #0]
  4008dc:	4543      	cmp	r3, r8
  4008de:	d108      	bne.n	4008f2 <pio_handler_process+0x36>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  4008e0:	6861      	ldr	r1, [r4, #4]
  4008e2:	4229      	tst	r1, r5
  4008e4:	d005      	beq.n	4008f2 <pio_handler_process+0x36>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  4008e6:	68e3      	ldr	r3, [r4, #12]
  4008e8:	4640      	mov	r0, r8
  4008ea:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  4008ec:	6863      	ldr	r3, [r4, #4]
  4008ee:	ea25 0503 	bic.w	r5, r5, r3
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  4008f2:	42b4      	cmp	r4, r6
  4008f4:	d002      	beq.n	4008fc <pio_handler_process+0x40>
  4008f6:	3410      	adds	r4, #16

	/* Check pending events */
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
  4008f8:	2d00      	cmp	r5, #0
  4008fa:	d1ee      	bne.n	4008da <pio_handler_process+0x1e>
		}
	}

	/* Check capture events */
#if (SAM3S || SAM4S || SAM4E)
	if (pio_capture_enable_flag) {
  4008fc:	4b07      	ldr	r3, [pc, #28]	; (40091c <pio_handler_process+0x60>)
  4008fe:	681b      	ldr	r3, [r3, #0]
  400900:	b123      	cbz	r3, 40090c <pio_handler_process+0x50>
		if (pio_capture_handler) {
  400902:	4b07      	ldr	r3, [pc, #28]	; (400920 <pio_handler_process+0x64>)
  400904:	681b      	ldr	r3, [r3, #0]
  400906:	b10b      	cbz	r3, 40090c <pio_handler_process+0x50>
			pio_capture_handler(p_pio);
  400908:	4648      	mov	r0, r9
  40090a:	4798      	blx	r3
  40090c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  400910:	00400759 	.word	0x00400759
  400914:	0040075d 	.word	0x0040075d
  400918:	200004d0 	.word	0x200004d0
  40091c:	20002684 	.word	0x20002684
  400920:	200004cc 	.word	0x200004cc

00400924 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  400924:	b508      	push	{r3, lr}
	pio_handler_process(PIOA, ID_PIOA);
  400926:	210b      	movs	r1, #11
  400928:	4801      	ldr	r0, [pc, #4]	; (400930 <PIOA_Handler+0xc>)
  40092a:	4b02      	ldr	r3, [pc, #8]	; (400934 <PIOA_Handler+0x10>)
  40092c:	4798      	blx	r3
  40092e:	bd08      	pop	{r3, pc}
  400930:	400e0e00 	.word	0x400e0e00
  400934:	004008bd 	.word	0x004008bd

00400938 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  400938:	b508      	push	{r3, lr}
    pio_handler_process(PIOB, ID_PIOB);
  40093a:	210c      	movs	r1, #12
  40093c:	4801      	ldr	r0, [pc, #4]	; (400944 <PIOB_Handler+0xc>)
  40093e:	4b02      	ldr	r3, [pc, #8]	; (400948 <PIOB_Handler+0x10>)
  400940:	4798      	blx	r3
  400942:	bd08      	pop	{r3, pc}
  400944:	400e1000 	.word	0x400e1000
  400948:	004008bd 	.word	0x004008bd

0040094c <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
  40094c:	b508      	push	{r3, lr}
	pio_handler_process(PIOC, ID_PIOC);
  40094e:	210d      	movs	r1, #13
  400950:	4801      	ldr	r0, [pc, #4]	; (400958 <PIOC_Handler+0xc>)
  400952:	4b02      	ldr	r3, [pc, #8]	; (40095c <PIOC_Handler+0x10>)
  400954:	4798      	blx	r3
  400956:	bd08      	pop	{r3, pc}
  400958:	400e1200 	.word	0x400e1200
  40095c:	004008bd 	.word	0x004008bd

00400960 <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  400960:	4a18      	ldr	r2, [pc, #96]	; (4009c4 <pmc_switch_mck_to_pllack+0x64>)
  400962:	6b13      	ldr	r3, [r2, #48]	; 0x30
  400964:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  400968:	4318      	orrs	r0, r3
  40096a:	6310      	str	r0, [r2, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40096c:	6e93      	ldr	r3, [r2, #104]	; 0x68
  40096e:	f013 0f08 	tst.w	r3, #8
  400972:	d003      	beq.n	40097c <pmc_switch_mck_to_pllack+0x1c>
  400974:	e009      	b.n	40098a <pmc_switch_mck_to_pllack+0x2a>
			--ul_timeout) {
		if (ul_timeout == 0) {
  400976:	3b01      	subs	r3, #1
  400978:	d103      	bne.n	400982 <pmc_switch_mck_to_pllack+0x22>
  40097a:	e01e      	b.n	4009ba <pmc_switch_mck_to_pllack+0x5a>
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40097c:	f44f 6300 	mov.w	r3, #2048	; 0x800
  400980:	4910      	ldr	r1, [pc, #64]	; (4009c4 <pmc_switch_mck_to_pllack+0x64>)
  400982:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  400984:	f012 0f08 	tst.w	r2, #8
  400988:	d0f5      	beq.n	400976 <pmc_switch_mck_to_pllack+0x16>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  40098a:	4a0e      	ldr	r2, [pc, #56]	; (4009c4 <pmc_switch_mck_to_pllack+0x64>)
  40098c:	6b13      	ldr	r3, [r2, #48]	; 0x30
  40098e:	f023 0303 	bic.w	r3, r3, #3
  400992:	f043 0302 	orr.w	r3, r3, #2
  400996:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  400998:	6e90      	ldr	r0, [r2, #104]	; 0x68
  40099a:	f010 0008 	ands.w	r0, r0, #8
  40099e:	d004      	beq.n	4009aa <pmc_switch_mck_to_pllack+0x4a>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  4009a0:	2000      	movs	r0, #0
  4009a2:	4770      	bx	lr
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
  4009a4:	3b01      	subs	r3, #1
  4009a6:	d103      	bne.n	4009b0 <pmc_switch_mck_to_pllack+0x50>
  4009a8:	e009      	b.n	4009be <pmc_switch_mck_to_pllack+0x5e>
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4009aa:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4009ae:	4905      	ldr	r1, [pc, #20]	; (4009c4 <pmc_switch_mck_to_pllack+0x64>)
  4009b0:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  4009b2:	f012 0f08 	tst.w	r2, #8
  4009b6:	d0f5      	beq.n	4009a4 <pmc_switch_mck_to_pllack+0x44>
  4009b8:	4770      	bx	lr

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  4009ba:	2001      	movs	r0, #1
  4009bc:	4770      	bx	lr
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  4009be:	2001      	movs	r0, #1
		}
	}

	return 0;
}
  4009c0:	4770      	bx	lr
  4009c2:	bf00      	nop
  4009c4:	400e0400 	.word	0x400e0400

004009c8 <pmc_switch_mainck_to_fastrc>:
 * \retval 2 Invalid frequency.
 */
void pmc_switch_mainck_to_fastrc(uint32_t ul_moscrcf)
{
	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	PMC->CKGR_MOR |= (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN);
  4009c8:	4b11      	ldr	r3, [pc, #68]	; (400a10 <pmc_switch_mainck_to_fastrc+0x48>)
  4009ca:	6a1a      	ldr	r2, [r3, #32]
  4009cc:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
  4009d0:	f042 0208 	orr.w	r2, r2, #8
  4009d4:	621a      	str	r2, [r3, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  4009d6:	461a      	mov	r2, r3
  4009d8:	6e93      	ldr	r3, [r2, #104]	; 0x68
  4009da:	f413 3f00 	tst.w	r3, #131072	; 0x20000
  4009de:	d0fb      	beq.n	4009d8 <pmc_switch_mainck_to_fastrc+0x10>

	/* Change Fast RC oscillator frequency */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  4009e0:	4a0b      	ldr	r2, [pc, #44]	; (400a10 <pmc_switch_mainck_to_fastrc+0x48>)
  4009e2:	6a13      	ldr	r3, [r2, #32]
			CKGR_MOR_KEY_PASSWD | ul_moscrcf;
  4009e4:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  4009e8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  4009ec:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  4009f0:	4303      	orrs	r3, r0

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));

	/* Change Fast RC oscillator frequency */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  4009f2:	6213      	str	r3, [r2, #32]
			CKGR_MOR_KEY_PASSWD | ul_moscrcf;

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  4009f4:	6e93      	ldr	r3, [r2, #104]	; 0x68
  4009f6:	f413 3f00 	tst.w	r3, #131072	; 0x20000
  4009fa:	d0fb      	beq.n	4009f4 <pmc_switch_mainck_to_fastrc+0x2c>

	/* Switch to Fast RC */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) |
  4009fc:	4a04      	ldr	r2, [pc, #16]	; (400a10 <pmc_switch_mainck_to_fastrc+0x48>)
  4009fe:	6a13      	ldr	r3, [r2, #32]
  400a00:	f023 739b 	bic.w	r3, r3, #20316160	; 0x1360000
  400a04:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  400a08:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  400a0c:	6213      	str	r3, [r2, #32]
  400a0e:	4770      	bx	lr
  400a10:	400e0400 	.word	0x400e0400

00400a14 <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  400a14:	4b02      	ldr	r3, [pc, #8]	; (400a20 <pmc_osc_is_ready_mainck+0xc>)
  400a16:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  400a18:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
  400a1c:	4770      	bx	lr
  400a1e:	bf00      	nop
  400a20:	400e0400 	.word	0x400e0400

00400a24 <pmc_disable_pllack>:
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  400a24:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  400a28:	4b01      	ldr	r3, [pc, #4]	; (400a30 <pmc_disable_pllack+0xc>)
  400a2a:	629a      	str	r2, [r3, #40]	; 0x28
  400a2c:	4770      	bx	lr
  400a2e:	bf00      	nop
  400a30:	400e0400 	.word	0x400e0400

00400a34 <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  400a34:	4b02      	ldr	r3, [pc, #8]	; (400a40 <pmc_is_locked_pllack+0xc>)
  400a36:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  400a38:	f000 0002 	and.w	r0, r0, #2
  400a3c:	4770      	bx	lr
  400a3e:	bf00      	nop
  400a40:	400e0400 	.word	0x400e0400

00400a44 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  400a44:	e7fe      	b.n	400a44 <Dummy_Handler>
  400a46:	bf00      	nop

00400a48 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  400a48:	b508      	push	{r3, lr}

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
  400a4a:	4b20      	ldr	r3, [pc, #128]	; (400acc <Reset_Handler+0x84>)
  400a4c:	4a20      	ldr	r2, [pc, #128]	; (400ad0 <Reset_Handler+0x88>)
  400a4e:	429a      	cmp	r2, r3
  400a50:	d912      	bls.n	400a78 <Reset_Handler+0x30>
		for (; pDest < &_erelocate;) {
  400a52:	4b20      	ldr	r3, [pc, #128]	; (400ad4 <Reset_Handler+0x8c>)
  400a54:	4a1d      	ldr	r2, [pc, #116]	; (400acc <Reset_Handler+0x84>)
  400a56:	429a      	cmp	r2, r3
  400a58:	d21e      	bcs.n	400a98 <Reset_Handler+0x50>
  400a5a:	4611      	mov	r1, r2
  400a5c:	3b01      	subs	r3, #1
  400a5e:	1a9b      	subs	r3, r3, r2
  400a60:	f023 0303 	bic.w	r3, r3, #3
  400a64:	3304      	adds	r3, #4
  400a66:	4a1a      	ldr	r2, [pc, #104]	; (400ad0 <Reset_Handler+0x88>)
  400a68:	4413      	add	r3, r2
			*pDest++ = *pSrc++;
  400a6a:	f852 0b04 	ldr.w	r0, [r2], #4
  400a6e:	f841 0b04 	str.w	r0, [r1], #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
  400a72:	429a      	cmp	r2, r3
  400a74:	d1f9      	bne.n	400a6a <Reset_Handler+0x22>
  400a76:	e00f      	b.n	400a98 <Reset_Handler+0x50>
			*pDest++ = *pSrc++;
		}
	} else if (pSrc < pDest) {
  400a78:	4b14      	ldr	r3, [pc, #80]	; (400acc <Reset_Handler+0x84>)
  400a7a:	4a15      	ldr	r2, [pc, #84]	; (400ad0 <Reset_Handler+0x88>)
  400a7c:	429a      	cmp	r2, r3
  400a7e:	d20b      	bcs.n	400a98 <Reset_Handler+0x50>
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
  400a80:	4b14      	ldr	r3, [pc, #80]	; (400ad4 <Reset_Handler+0x8c>)
  400a82:	4a12      	ldr	r2, [pc, #72]	; (400acc <Reset_Handler+0x84>)
  400a84:	1a9a      	subs	r2, r3, r2
  400a86:	4814      	ldr	r0, [pc, #80]	; (400ad8 <Reset_Handler+0x90>)
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
  400a88:	1811      	adds	r1, r2, r0
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  400a8a:	b12a      	cbz	r2, 400a98 <Reset_Handler+0x50>
			*pDest-- = *pSrc--;
  400a8c:	f851 2904 	ldr.w	r2, [r1], #-4
  400a90:	f843 2d04 	str.w	r2, [r3, #-4]!
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  400a94:	4281      	cmp	r1, r0
  400a96:	d1f9      	bne.n	400a8c <Reset_Handler+0x44>

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
  400a98:	bf00      	nop
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  400a9a:	4b10      	ldr	r3, [pc, #64]	; (400adc <Reset_Handler+0x94>)
  400a9c:	4a10      	ldr	r2, [pc, #64]	; (400ae0 <Reset_Handler+0x98>)
  400a9e:	429a      	cmp	r2, r3
  400aa0:	d20b      	bcs.n	400aba <Reset_Handler+0x72>
  400aa2:	1d13      	adds	r3, r2, #4
  400aa4:	4a0f      	ldr	r2, [pc, #60]	; (400ae4 <Reset_Handler+0x9c>)
  400aa6:	1ad2      	subs	r2, r2, r3
  400aa8:	f022 0203 	bic.w	r2, r2, #3
  400aac:	441a      	add	r2, r3
  400aae:	3b04      	subs	r3, #4
		*pDest++ = 0;
  400ab0:	2100      	movs	r1, #0
  400ab2:	f843 1b04 	str.w	r1, [r3], #4
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  400ab6:	429a      	cmp	r2, r3
  400ab8:	d1fb      	bne.n	400ab2 <Reset_Handler+0x6a>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
	SCB->VTOR = ((uint32_t) pSrc);
  400aba:	4b0b      	ldr	r3, [pc, #44]	; (400ae8 <Reset_Handler+0xa0>)
  400abc:	4a0b      	ldr	r2, [pc, #44]	; (400aec <Reset_Handler+0xa4>)
  400abe:	609a      	str	r2, [r3, #8]

	/* Initialize the C library */
	__libc_init_array();
  400ac0:	4b0b      	ldr	r3, [pc, #44]	; (400af0 <Reset_Handler+0xa8>)
  400ac2:	4798      	blx	r3

	/* Branch to main function */
	main();
  400ac4:	4b0b      	ldr	r3, [pc, #44]	; (400af4 <Reset_Handler+0xac>)
  400ac6:	4798      	blx	r3
  400ac8:	e7fe      	b.n	400ac8 <Reset_Handler+0x80>
  400aca:	bf00      	nop
  400acc:	20000000 	.word	0x20000000
  400ad0:	00402684 	.word	0x00402684
  400ad4:	20000438 	.word	0x20000438
  400ad8:	00402680 	.word	0x00402680
  400adc:	20002688 	.word	0x20002688
  400ae0:	20000438 	.word	0x20000438
  400ae4:	2000268b 	.word	0x2000268b
  400ae8:	e000ed00 	.word	0xe000ed00
  400aec:	00400000 	.word	0x00400000
  400af0:	0040228d 	.word	0x0040228d
  400af4:	0040224d 	.word	0x0040224d

00400af8 <SystemCoreClockUpdate>:
 * \brief Get Core Clock Frequency.
 */
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
  400af8:	4b3d      	ldr	r3, [pc, #244]	; (400bf0 <SystemCoreClockUpdate+0xf8>)
  400afa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  400afc:	f003 0303 	and.w	r3, r3, #3
  400b00:	2b03      	cmp	r3, #3
  400b02:	d85d      	bhi.n	400bc0 <SystemCoreClockUpdate+0xc8>
  400b04:	e8df f003 	tbb	[pc, r3]
  400b08:	2b2b0e02 	.word	0x2b2b0e02
	case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
			if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  400b0c:	4b39      	ldr	r3, [pc, #228]	; (400bf4 <SystemCoreClockUpdate+0xfc>)
  400b0e:	695b      	ldr	r3, [r3, #20]
  400b10:	f013 0f80 	tst.w	r3, #128	; 0x80
				SystemCoreClock = CHIP_FREQ_XTAL_32K;
  400b14:	bf14      	ite	ne
  400b16:	f44f 4200 	movne.w	r2, #32768	; 0x8000
			} else {
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
  400b1a:	f44f 42fa 	moveq.w	r2, #32000	; 0x7d00
  400b1e:	4b36      	ldr	r3, [pc, #216]	; (400bf8 <SystemCoreClockUpdate+0x100>)
  400b20:	601a      	str	r2, [r3, #0]
  400b22:	e04d      	b.n	400bc0 <SystemCoreClockUpdate+0xc8>
			}
		break;
		
	case PMC_MCKR_CSS_MAIN_CLK: /* Main clock */
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  400b24:	4b32      	ldr	r3, [pc, #200]	; (400bf0 <SystemCoreClockUpdate+0xf8>)
  400b26:	6a1b      	ldr	r3, [r3, #32]
  400b28:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  400b2c:	d003      	beq.n	400b36 <SystemCoreClockUpdate+0x3e>
			SystemCoreClock = CHIP_FREQ_XTAL;
  400b2e:	4a33      	ldr	r2, [pc, #204]	; (400bfc <SystemCoreClockUpdate+0x104>)
  400b30:	4b31      	ldr	r3, [pc, #196]	; (400bf8 <SystemCoreClockUpdate+0x100>)
  400b32:	601a      	str	r2, [r3, #0]
  400b34:	e044      	b.n	400bc0 <SystemCoreClockUpdate+0xc8>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  400b36:	4a32      	ldr	r2, [pc, #200]	; (400c00 <SystemCoreClockUpdate+0x108>)
  400b38:	4b2f      	ldr	r3, [pc, #188]	; (400bf8 <SystemCoreClockUpdate+0x100>)
  400b3a:	601a      	str	r2, [r3, #0]
			
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  400b3c:	4b2c      	ldr	r3, [pc, #176]	; (400bf0 <SystemCoreClockUpdate+0xf8>)
  400b3e:	6a1b      	ldr	r3, [r3, #32]
  400b40:	f003 0370 	and.w	r3, r3, #112	; 0x70
  400b44:	2b10      	cmp	r3, #16
  400b46:	d002      	beq.n	400b4e <SystemCoreClockUpdate+0x56>
  400b48:	2b20      	cmp	r3, #32
  400b4a:	d004      	beq.n	400b56 <SystemCoreClockUpdate+0x5e>
  400b4c:	e038      	b.n	400bc0 <SystemCoreClockUpdate+0xc8>
			case CKGR_MOR_MOSCRCF_4_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
			break;
			
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  400b4e:	4a2d      	ldr	r2, [pc, #180]	; (400c04 <SystemCoreClockUpdate+0x10c>)
  400b50:	4b29      	ldr	r3, [pc, #164]	; (400bf8 <SystemCoreClockUpdate+0x100>)
  400b52:	601a      	str	r2, [r3, #0]
			break;
  400b54:	e034      	b.n	400bc0 <SystemCoreClockUpdate+0xc8>
			
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  400b56:	4a29      	ldr	r2, [pc, #164]	; (400bfc <SystemCoreClockUpdate+0x104>)
  400b58:	4b27      	ldr	r3, [pc, #156]	; (400bf8 <SystemCoreClockUpdate+0x100>)
  400b5a:	601a      	str	r2, [r3, #0]
			break;
  400b5c:	e030      	b.n	400bc0 <SystemCoreClockUpdate+0xc8>
		}
		break;
		
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
			if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  400b5e:	4b24      	ldr	r3, [pc, #144]	; (400bf0 <SystemCoreClockUpdate+0xf8>)
  400b60:	6a1b      	ldr	r3, [r3, #32]
  400b62:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  400b66:	d003      	beq.n	400b70 <SystemCoreClockUpdate+0x78>
				SystemCoreClock = CHIP_FREQ_XTAL;
  400b68:	4a24      	ldr	r2, [pc, #144]	; (400bfc <SystemCoreClockUpdate+0x104>)
  400b6a:	4b23      	ldr	r3, [pc, #140]	; (400bf8 <SystemCoreClockUpdate+0x100>)
  400b6c:	601a      	str	r2, [r3, #0]
  400b6e:	e012      	b.n	400b96 <SystemCoreClockUpdate+0x9e>
			} else {
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  400b70:	4a23      	ldr	r2, [pc, #140]	; (400c00 <SystemCoreClockUpdate+0x108>)
  400b72:	4b21      	ldr	r3, [pc, #132]	; (400bf8 <SystemCoreClockUpdate+0x100>)
  400b74:	601a      	str	r2, [r3, #0]
				
				switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  400b76:	4b1e      	ldr	r3, [pc, #120]	; (400bf0 <SystemCoreClockUpdate+0xf8>)
  400b78:	6a1b      	ldr	r3, [r3, #32]
  400b7a:	f003 0370 	and.w	r3, r3, #112	; 0x70
  400b7e:	2b10      	cmp	r3, #16
  400b80:	d002      	beq.n	400b88 <SystemCoreClockUpdate+0x90>
  400b82:	2b20      	cmp	r3, #32
  400b84:	d004      	beq.n	400b90 <SystemCoreClockUpdate+0x98>
  400b86:	e006      	b.n	400b96 <SystemCoreClockUpdate+0x9e>
				case CKGR_MOR_MOSCRCF_4_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
					break;
				
				case CKGR_MOR_MOSCRCF_8_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  400b88:	4a1e      	ldr	r2, [pc, #120]	; (400c04 <SystemCoreClockUpdate+0x10c>)
  400b8a:	4b1b      	ldr	r3, [pc, #108]	; (400bf8 <SystemCoreClockUpdate+0x100>)
  400b8c:	601a      	str	r2, [r3, #0]
					break;
  400b8e:	e002      	b.n	400b96 <SystemCoreClockUpdate+0x9e>
				
				case CKGR_MOR_MOSCRCF_12_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  400b90:	4a1a      	ldr	r2, [pc, #104]	; (400bfc <SystemCoreClockUpdate+0x104>)
  400b92:	4b19      	ldr	r3, [pc, #100]	; (400bf8 <SystemCoreClockUpdate+0x100>)
  400b94:	601a      	str	r2, [r3, #0]
				default:
					break;
				}
			}
			
			if ( (uint32_t)(PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) ==
  400b96:	4b16      	ldr	r3, [pc, #88]	; (400bf0 <SystemCoreClockUpdate+0xf8>)
  400b98:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  400b9a:	f003 0303 	and.w	r3, r3, #3
  400b9e:	2b02      	cmp	r3, #2
					PMC_MCKR_CSS_PLLA_CLK ) {
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
  400ba0:	4a13      	ldr	r2, [pc, #76]	; (400bf0 <SystemCoreClockUpdate+0xf8>)
  400ba2:	bf07      	ittee	eq
  400ba4:	6a93      	ldreq	r3, [r2, #40]	; 0x28
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
  400ba6:	6a92      	ldreq	r2, [r2, #40]	; 0x28
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  400ba8:	6ad3      	ldrne	r3, [r2, #44]	; 0x2c
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  400baa:	6ad2      	ldrne	r2, [r2, #44]	; 0x2c
  400bac:	4812      	ldr	r0, [pc, #72]	; (400bf8 <SystemCoreClockUpdate+0x100>)
  400bae:	f3c3 410a 	ubfx	r1, r3, #16, #11
  400bb2:	6803      	ldr	r3, [r0, #0]
  400bb4:	fb01 3303 	mla	r3, r1, r3, r3
  400bb8:	b2d2      	uxtb	r2, r2
  400bba:	fbb3 f3f2 	udiv	r3, r3, r2
  400bbe:	6003      	str	r3, [r0, #0]
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  400bc0:	4b0b      	ldr	r3, [pc, #44]	; (400bf0 <SystemCoreClockUpdate+0xf8>)
  400bc2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  400bc4:	f003 0370 	and.w	r3, r3, #112	; 0x70
  400bc8:	2b70      	cmp	r3, #112	; 0x70
  400bca:	d107      	bne.n	400bdc <SystemCoreClockUpdate+0xe4>
		SystemCoreClock /= 3U;
  400bcc:	4a0a      	ldr	r2, [pc, #40]	; (400bf8 <SystemCoreClockUpdate+0x100>)
  400bce:	6813      	ldr	r3, [r2, #0]
  400bd0:	490d      	ldr	r1, [pc, #52]	; (400c08 <SystemCoreClockUpdate+0x110>)
  400bd2:	fba1 1303 	umull	r1, r3, r1, r3
  400bd6:	085b      	lsrs	r3, r3, #1
  400bd8:	6013      	str	r3, [r2, #0]
  400bda:	4770      	bx	lr
	} else {
		SystemCoreClock >>=
			((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  400bdc:	4b04      	ldr	r3, [pc, #16]	; (400bf0 <SystemCoreClockUpdate+0xf8>)
  400bde:	6b1b      	ldr	r3, [r3, #48]	; 0x30
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>=
  400be0:	4905      	ldr	r1, [pc, #20]	; (400bf8 <SystemCoreClockUpdate+0x100>)
  400be2:	f3c3 1202 	ubfx	r2, r3, #4, #3
  400be6:	680b      	ldr	r3, [r1, #0]
  400be8:	40d3      	lsrs	r3, r2
  400bea:	600b      	str	r3, [r1, #0]
  400bec:	4770      	bx	lr
  400bee:	bf00      	nop
  400bf0:	400e0400 	.word	0x400e0400
  400bf4:	400e1410 	.word	0x400e1410
  400bf8:	20000000 	.word	0x20000000
  400bfc:	00b71b00 	.word	0x00b71b00
  400c00:	003d0900 	.word	0x003d0900
  400c04:	007a1200 	.word	0x007a1200
  400c08:	aaaaaaab 	.word	0xaaaaaaab

00400c0c <system_init_flash>:
				}
			}
		}
	}
#else
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
  400c0c:	4b1a      	ldr	r3, [pc, #104]	; (400c78 <system_init_flash+0x6c>)
  400c0e:	4298      	cmp	r0, r3
  400c10:	d807      	bhi.n	400c22 <system_init_flash+0x16>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  400c12:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
  400c16:	4a19      	ldr	r2, [pc, #100]	; (400c7c <system_init_flash+0x70>)
  400c18:	6013      	str	r3, [r2, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  400c1a:	f502 7200 	add.w	r2, r2, #512	; 0x200
  400c1e:	6013      	str	r3, [r2, #0]
  400c20:	4770      	bx	lr
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
  400c22:	4b17      	ldr	r3, [pc, #92]	; (400c80 <system_init_flash+0x74>)
  400c24:	4298      	cmp	r0, r3
  400c26:	d806      	bhi.n	400c36 <system_init_flash+0x2a>
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  400c28:	4b16      	ldr	r3, [pc, #88]	; (400c84 <system_init_flash+0x78>)
  400c2a:	4a14      	ldr	r2, [pc, #80]	; (400c7c <system_init_flash+0x70>)
  400c2c:	6013      	str	r3, [r2, #0]
			EFC1->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  400c2e:	f502 7200 	add.w	r2, r2, #512	; 0x200
  400c32:	6013      	str	r3, [r2, #0]
  400c34:	4770      	bx	lr
		} else {
			if ( ul_clk < CHIP_FREQ_FWS_2 ) {
  400c36:	4b14      	ldr	r3, [pc, #80]	; (400c88 <system_init_flash+0x7c>)
  400c38:	4298      	cmp	r0, r3
  400c3a:	d806      	bhi.n	400c4a <system_init_flash+0x3e>
				EFC0->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  400c3c:	4b13      	ldr	r3, [pc, #76]	; (400c8c <system_init_flash+0x80>)
  400c3e:	4a0f      	ldr	r2, [pc, #60]	; (400c7c <system_init_flash+0x70>)
  400c40:	6013      	str	r3, [r2, #0]
				EFC1->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  400c42:	f502 7200 	add.w	r2, r2, #512	; 0x200
  400c46:	6013      	str	r3, [r2, #0]
  400c48:	4770      	bx	lr
			} else {
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
  400c4a:	4b11      	ldr	r3, [pc, #68]	; (400c90 <system_init_flash+0x84>)
  400c4c:	4298      	cmp	r0, r3
  400c4e:	d806      	bhi.n	400c5e <system_init_flash+0x52>
					EFC0->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  400c50:	4b10      	ldr	r3, [pc, #64]	; (400c94 <system_init_flash+0x88>)
  400c52:	4a0a      	ldr	r2, [pc, #40]	; (400c7c <system_init_flash+0x70>)
  400c54:	6013      	str	r3, [r2, #0]
					EFC1->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  400c56:	f502 7200 	add.w	r2, r2, #512	; 0x200
  400c5a:	6013      	str	r3, [r2, #0]
  400c5c:	4770      	bx	lr
				} else {
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
  400c5e:	4b0e      	ldr	r3, [pc, #56]	; (400c98 <system_init_flash+0x8c>)
  400c60:	4298      	cmp	r0, r3
						EFC0->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  400c62:	bf94      	ite	ls
  400c64:	f04f 2304 	movls.w	r3, #67109888	; 0x4000400
						EFC1->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
					} else {
						EFC0->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  400c68:	4b0c      	ldrhi	r3, [pc, #48]	; (400c9c <system_init_flash+0x90>)
  400c6a:	4a04      	ldr	r2, [pc, #16]	; (400c7c <system_init_flash+0x70>)
  400c6c:	6013      	str	r3, [r2, #0]
						EFC1->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  400c6e:	f502 7200 	add.w	r2, r2, #512	; 0x200
  400c72:	6013      	str	r3, [r2, #0]
  400c74:	4770      	bx	lr
  400c76:	bf00      	nop
  400c78:	01312cff 	.word	0x01312cff
  400c7c:	400e0a00 	.word	0x400e0a00
  400c80:	026259ff 	.word	0x026259ff
  400c84:	04000100 	.word	0x04000100
  400c88:	039386ff 	.word	0x039386ff
  400c8c:	04000200 	.word	0x04000200
  400c90:	04c4b3ff 	.word	0x04c4b3ff
  400c94:	04000300 	.word	0x04000300
  400c98:	05f5e0ff 	.word	0x05f5e0ff
  400c9c:	04000500 	.word	0x04000500

00400ca0 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
  400ca0:	f100 0308 	add.w	r3, r0, #8
  400ca4:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  400ca6:	f04f 32ff 	mov.w	r2, #4294967295
  400caa:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
  400cac:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
  400cae:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
  400cb0:	2300      	movs	r3, #0
  400cb2:	6003      	str	r3, [r0, #0]
  400cb4:	4770      	bx	lr
  400cb6:	bf00      	nop

00400cb8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
  400cb8:	2300      	movs	r3, #0
  400cba:	6103      	str	r3, [r0, #16]
  400cbc:	4770      	bx	lr
  400cbe:	bf00      	nop

00400cc0 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
  400cc0:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
  400cc2:	685a      	ldr	r2, [r3, #4]
  400cc4:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
  400cc6:	6842      	ldr	r2, [r0, #4]
  400cc8:	608a      	str	r2, [r1, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  400cca:	685a      	ldr	r2, [r3, #4]
  400ccc:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
  400cce:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
  400cd0:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  400cd2:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  400cd4:	6803      	ldr	r3, [r0, #0]
  400cd6:	3301      	adds	r3, #1
  400cd8:	6003      	str	r3, [r0, #0]
  400cda:	4770      	bx	lr

00400cdc <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
  400cdc:	b410      	push	{r4}
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
  400cde:	680c      	ldr	r4, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  400ce0:	f1b4 3fff 	cmp.w	r4, #4294967295
  400ce4:	d101      	bne.n	400cea <vListInsert+0xe>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  400ce6:	6903      	ldr	r3, [r0, #16]
  400ce8:	e00a      	b.n	400d00 <vListInsert+0x24>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
  400cea:	f100 0308 	add.w	r3, r0, #8
  400cee:	68c2      	ldr	r2, [r0, #12]
  400cf0:	6812      	ldr	r2, [r2, #0]
  400cf2:	4294      	cmp	r4, r2
  400cf4:	d304      	bcc.n	400d00 <vListInsert+0x24>
  400cf6:	685b      	ldr	r3, [r3, #4]
  400cf8:	685a      	ldr	r2, [r3, #4]
  400cfa:	6812      	ldr	r2, [r2, #0]
  400cfc:	4294      	cmp	r4, r2
  400cfe:	d2fa      	bcs.n	400cf6 <vListInsert+0x1a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  400d00:	685a      	ldr	r2, [r3, #4]
  400d02:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  400d04:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
  400d06:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
  400d08:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  400d0a:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  400d0c:	6803      	ldr	r3, [r0, #0]
  400d0e:	3301      	adds	r3, #1
  400d10:	6003      	str	r3, [r0, #0]
}
  400d12:	bc10      	pop	{r4}
  400d14:	4770      	bx	lr
  400d16:	bf00      	nop

00400d18 <uxListRemove>:

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  400d18:	6843      	ldr	r3, [r0, #4]
  400d1a:	6882      	ldr	r2, [r0, #8]
  400d1c:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  400d1e:	6883      	ldr	r3, [r0, #8]
  400d20:	6842      	ldr	r2, [r0, #4]
  400d22:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
  400d24:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  400d26:	685a      	ldr	r2, [r3, #4]
  400d28:	4290      	cmp	r0, r2
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  400d2a:	bf04      	itt	eq
  400d2c:	6882      	ldreq	r2, [r0, #8]
  400d2e:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
  400d30:	2200      	movs	r2, #0
  400d32:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
  400d34:	681a      	ldr	r2, [r3, #0]
  400d36:	3a01      	subs	r2, #1
  400d38:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
  400d3a:	6818      	ldr	r0, [r3, #0]
}
  400d3c:	4770      	bx	lr
  400d3e:	bf00      	nop

00400d40 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
  400d40:	4803      	ldr	r0, [pc, #12]	; (400d50 <prvPortStartFirstTask+0x10>)
  400d42:	6800      	ldr	r0, [r0, #0]
  400d44:	6800      	ldr	r0, [r0, #0]
  400d46:	f380 8808 	msr	MSP, r0
  400d4a:	b662      	cpsie	i
  400d4c:	df00      	svc	0
  400d4e:	bf00      	nop
  400d50:	e000ed08 	.word	0xe000ed08

00400d54 <pxPortInitialiseStack>:
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
  400d54:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
  400d58:	f840 3c04 	str.w	r3, [r0, #-4]
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
  400d5c:	f840 1c08 	str.w	r1, [r0, #-8]
	pxTopOfStack--;
	*pxTopOfStack = 0;	/* LR */
  400d60:	2300      	movs	r3, #0
  400d62:	f840 3c0c 	str.w	r3, [r0, #-12]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
  400d66:	f840 2c20 	str.w	r2, [r0, #-32]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
  400d6a:	3840      	subs	r0, #64	; 0x40
  400d6c:	4770      	bx	lr
  400d6e:	bf00      	nop

00400d70 <SVC_Handler>:
/*-----------------------------------------------------------*/

__attribute__ (( naked )) void SVC_Handler( void )
{
	__asm volatile (
  400d70:	4b06      	ldr	r3, [pc, #24]	; (400d8c <pxCurrentTCBConst2>)
  400d72:	6819      	ldr	r1, [r3, #0]
  400d74:	6808      	ldr	r0, [r1, #0]
  400d76:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  400d7a:	f380 8809 	msr	PSP, r0
  400d7e:	f04f 0000 	mov.w	r0, #0
  400d82:	f380 8811 	msr	BASEPRI, r0
  400d86:	f04e 0e0d 	orr.w	lr, lr, #13
  400d8a:	4770      	bx	lr

00400d8c <pxCurrentTCBConst2>:
  400d8c:	20002600 	.word	0x20002600

00400d90 <vPortYieldFromISR>:
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  400d90:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  400d94:	4b01      	ldr	r3, [pc, #4]	; (400d9c <vPortYieldFromISR+0xc>)
  400d96:	601a      	str	r2, [r3, #0]
  400d98:	4770      	bx	lr
  400d9a:	bf00      	nop
  400d9c:	e000ed04 	.word	0xe000ed04

00400da0 <ulPortSetInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile														\
  400da0:	f3ef 8011 	mrs	r0, BASEPRI
  400da4:	f04f 01a0 	mov.w	r1, #160	; 0xa0
  400da8:	f381 8811 	msr	BASEPRI, r1
  400dac:	4770      	bx	lr
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
}
  400dae:	2000      	movs	r0, #0

00400db0 <vPortEnterCritical>:
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
  400db0:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
  400db2:	4b03      	ldr	r3, [pc, #12]	; (400dc0 <vPortEnterCritical+0x10>)
  400db4:	4798      	blx	r3
	uxCriticalNesting++;
  400db6:	4a03      	ldr	r2, [pc, #12]	; (400dc4 <vPortEnterCritical+0x14>)
  400db8:	6813      	ldr	r3, [r2, #0]
  400dba:	3301      	adds	r3, #1
  400dbc:	6013      	str	r3, [r2, #0]
  400dbe:	bd08      	pop	{r3, pc}
  400dc0:	00400da1 	.word	0x00400da1
  400dc4:	20000004 	.word	0x20000004

00400dc8 <vPortClearInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( unsigned long ulNewMaskValue )
{
	__asm volatile													\
  400dc8:	f380 8811 	msr	BASEPRI, r0
  400dcc:	4770      	bx	lr
  400dce:	bf00      	nop

00400dd0 <vPortExitCritical>:
	uxCriticalNesting++;
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
  400dd0:	b508      	push	{r3, lr}
	uxCriticalNesting--;
  400dd2:	4a04      	ldr	r2, [pc, #16]	; (400de4 <vPortExitCritical+0x14>)
  400dd4:	6813      	ldr	r3, [r2, #0]
  400dd6:	3b01      	subs	r3, #1
  400dd8:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
  400dda:	b913      	cbnz	r3, 400de2 <vPortExitCritical+0x12>
	{
		portENABLE_INTERRUPTS();
  400ddc:	2000      	movs	r0, #0
  400dde:	4b02      	ldr	r3, [pc, #8]	; (400de8 <vPortExitCritical+0x18>)
  400de0:	4798      	blx	r3
  400de2:	bd08      	pop	{r3, pc}
  400de4:	20000004 	.word	0x20000004
  400de8:	00400dc9 	.word	0x00400dc9

00400dec <PendSV_Handler>:

__attribute__(( naked )) void PendSV_Handler( void )
{
	/* This is a naked function. */

	__asm volatile
  400dec:	f3ef 8009 	mrs	r0, PSP
  400df0:	4b0c      	ldr	r3, [pc, #48]	; (400e24 <pxCurrentTCBConst>)
  400df2:	681a      	ldr	r2, [r3, #0]
  400df4:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  400df8:	6010      	str	r0, [r2, #0]
  400dfa:	e92d 4008 	stmdb	sp!, {r3, lr}
  400dfe:	f04f 00a0 	mov.w	r0, #160	; 0xa0
  400e02:	f380 8811 	msr	BASEPRI, r0
  400e06:	f000 fe85 	bl	401b14 <vTaskSwitchContext>
  400e0a:	f04f 0000 	mov.w	r0, #0
  400e0e:	f380 8811 	msr	BASEPRI, r0
  400e12:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  400e16:	6819      	ldr	r1, [r3, #0]
  400e18:	6808      	ldr	r0, [r1, #0]
  400e1a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  400e1e:	f380 8809 	msr	PSP, r0
  400e22:	4770      	bx	lr

00400e24 <pxCurrentTCBConst>:
  400e24:	20002600 	.word	0x20002600

00400e28 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void SysTick_Handler( void )
{
  400e28:	b508      	push	{r3, lr}
	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  400e2a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  400e2e:	4b05      	ldr	r3, [pc, #20]	; (400e44 <SysTick_Handler+0x1c>)
  400e30:	601a      	str	r2, [r3, #0]
	to generate the tick interrupt. */
	#if configUSE_TICKLESS_IDLE == 1
		portNVIC_SYSTICK_LOAD_REG = ulTimerReloadValueForOneTick;
	#endif

	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
  400e32:	4b05      	ldr	r3, [pc, #20]	; (400e48 <SysTick_Handler+0x20>)
  400e34:	4798      	blx	r3
	{
		vTaskIncrementTick();
  400e36:	4b05      	ldr	r3, [pc, #20]	; (400e4c <SysTick_Handler+0x24>)
  400e38:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
  400e3a:	2000      	movs	r0, #0
  400e3c:	4b04      	ldr	r3, [pc, #16]	; (400e50 <SysTick_Handler+0x28>)
  400e3e:	4798      	blx	r3
  400e40:	bd08      	pop	{r3, pc}
  400e42:	bf00      	nop
  400e44:	e000ed04 	.word	0xe000ed04
  400e48:	00400da1 	.word	0x00400da1
  400e4c:	00401839 	.word	0x00401839
  400e50:	00400dc9 	.word	0x00400dc9

00400e54 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = 45UL / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
  400e54:	4a03      	ldr	r2, [pc, #12]	; (400e64 <vPortSetupTimerInterrupt+0x10>)
  400e56:	4b04      	ldr	r3, [pc, #16]	; (400e68 <vPortSetupTimerInterrupt+0x14>)
  400e58:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
  400e5a:	2207      	movs	r2, #7
  400e5c:	3b04      	subs	r3, #4
  400e5e:	601a      	str	r2, [r3, #0]
  400e60:	4770      	bx	lr
  400e62:	bf00      	nop
  400e64:	0001d4bf 	.word	0x0001d4bf
  400e68:	e000e014 	.word	0xe000e014

00400e6c <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
  400e6c:	b510      	push	{r4, lr}
	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
  400e6e:	4b09      	ldr	r3, [pc, #36]	; (400e94 <xPortStartScheduler+0x28>)
  400e70:	681a      	ldr	r2, [r3, #0]
  400e72:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
  400e76:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
  400e78:	681a      	ldr	r2, [r3, #0]
  400e7a:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
  400e7e:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
  400e80:	4b05      	ldr	r3, [pc, #20]	; (400e98 <xPortStartScheduler+0x2c>)
  400e82:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
  400e84:	2400      	movs	r4, #0
  400e86:	4b05      	ldr	r3, [pc, #20]	; (400e9c <xPortStartScheduler+0x30>)
  400e88:	601c      	str	r4, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
  400e8a:	4b05      	ldr	r3, [pc, #20]	; (400ea0 <xPortStartScheduler+0x34>)
  400e8c:	4798      	blx	r3

	/* Should not get here! */
	return 0;
}
  400e8e:	4620      	mov	r0, r4
  400e90:	bd10      	pop	{r4, pc}
  400e92:	bf00      	nop
  400e94:	e000ed20 	.word	0xe000ed20
  400e98:	00400e55 	.word	0x00400e55
  400e9c:	20000004 	.word	0x20000004
  400ea0:	00400d41 	.word	0x00400d41

00400ea4 <prvInsertBlockIntoFreeList>:
xBlockLink *pxIterator;
unsigned char *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  400ea4:	4a12      	ldr	r2, [pc, #72]	; (400ef0 <prvInsertBlockIntoFreeList+0x4c>)
  400ea6:	e000      	b.n	400eaa <prvInsertBlockIntoFreeList+0x6>
  400ea8:	461a      	mov	r2, r3
  400eaa:	6813      	ldr	r3, [r2, #0]
  400eac:	4283      	cmp	r3, r0
  400eae:	d3fb      	bcc.n	400ea8 <prvInsertBlockIntoFreeList+0x4>
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert )
{
  400eb0:	b410      	push	{r4}
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */	
	puc = ( unsigned char * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( unsigned char * ) pxBlockToInsert )
  400eb2:	6851      	ldr	r1, [r2, #4]
  400eb4:	1854      	adds	r4, r2, r1
  400eb6:	42a0      	cmp	r0, r4
  400eb8:	d103      	bne.n	400ec2 <prvInsertBlockIntoFreeList+0x1e>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  400eba:	6840      	ldr	r0, [r0, #4]
  400ebc:	4401      	add	r1, r0
  400ebe:	6051      	str	r1, [r2, #4]
  400ec0:	4610      	mov	r0, r2
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( unsigned char * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( unsigned char * ) pxIterator->pxNextFreeBlock )
  400ec2:	6841      	ldr	r1, [r0, #4]
  400ec4:	1844      	adds	r4, r0, r1
  400ec6:	42a3      	cmp	r3, r4
  400ec8:	d10c      	bne.n	400ee4 <prvInsertBlockIntoFreeList+0x40>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
  400eca:	4b0a      	ldr	r3, [pc, #40]	; (400ef4 <prvInsertBlockIntoFreeList+0x50>)
  400ecc:	681b      	ldr	r3, [r3, #0]
  400ece:	429c      	cmp	r4, r3
  400ed0:	d006      	beq.n	400ee0 <prvInsertBlockIntoFreeList+0x3c>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  400ed2:	6863      	ldr	r3, [r4, #4]
  400ed4:	4419      	add	r1, r3
  400ed6:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  400ed8:	6813      	ldr	r3, [r2, #0]
  400eda:	681b      	ldr	r3, [r3, #0]
  400edc:	6003      	str	r3, [r0, #0]
  400ede:	e002      	b.n	400ee6 <prvInsertBlockIntoFreeList+0x42>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
  400ee0:	6004      	str	r4, [r0, #0]
  400ee2:	e000      	b.n	400ee6 <prvInsertBlockIntoFreeList+0x42>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;		
  400ee4:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
  400ee6:	4290      	cmp	r0, r2
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  400ee8:	bf18      	it	ne
  400eea:	6010      	strne	r0, [r2, #0]
	}
}
  400eec:	bc10      	pop	{r4}
  400eee:	4770      	bx	lr
  400ef0:	20002544 	.word	0x20002544
  400ef4:	20002540 	.word	0x20002540

00400ef8 <pvPortMalloc>:
/* STATIC FUNCTIONS ARE DEFINED AS MACROS TO MINIMIZE THE FUNCTION CALL DEPTH. */

/*-----------------------------------------------------------*/
extern void vApplicationMallocFailedHook( void );
void *pvPortMalloc( size_t xWantedSize )
{
  400ef8:	b538      	push	{r3, r4, r5, lr}
  400efa:	4604      	mov	r4, r0
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
  400efc:	4b2b      	ldr	r3, [pc, #172]	; (400fac <pvPortMalloc+0xb4>)
  400efe:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
  400f00:	4b2b      	ldr	r3, [pc, #172]	; (400fb0 <pvPortMalloc+0xb8>)
  400f02:	681b      	ldr	r3, [r3, #0]
  400f04:	b99b      	cbnz	r3, 400f2e <pvPortMalloc+0x36>
	/* Ensure the start of the heap is aligned. */
	configASSERT( ( ( ( unsigned long ) xHeap.ucHeap ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) xHeap.ucHeap;
  400f06:	4a2b      	ldr	r2, [pc, #172]	; (400fb4 <pvPortMalloc+0xbc>)
  400f08:	4b2b      	ldr	r3, [pc, #172]	; (400fb8 <pvPortMalloc+0xc0>)
  400f0a:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
  400f0c:	2100      	movs	r1, #0
  400f0e:	6051      	str	r1, [r2, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	pucHeapEnd = xHeap.ucHeap + xTotalHeapSize;
	pucHeapEnd -= heapSTRUCT_SIZE;
	pxEnd = ( void * ) pucHeapEnd;
  400f10:	f641 72f0 	movw	r2, #8176	; 0x1ff0
  400f14:	1898      	adds	r0, r3, r2
  400f16:	4d26      	ldr	r5, [pc, #152]	; (400fb0 <pvPortMalloc+0xb8>)
  400f18:	6028      	str	r0, [r5, #0]
	configASSERT( ( ( ( unsigned long ) pxEnd ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );
	pxEnd->xBlockSize = 0;
  400f1a:	f641 75f4 	movw	r5, #8180	; 0x1ff4
  400f1e:	5159      	str	r1, [r3, r5]
	pxEnd->pxNextFreeBlock = NULL;
  400f20:	5099      	str	r1, [r3, r2]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) xHeap.ucHeap;
	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
  400f22:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  400f24:	6018      	str	r0, [r3, #0]

	/* The heap now contains pxEnd. */
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
  400f26:	4a25      	ldr	r2, [pc, #148]	; (400fbc <pvPortMalloc+0xc4>)
  400f28:	6813      	ldr	r3, [r2, #0]
  400f2a:	3b10      	subs	r3, #16
  400f2c:	6013      	str	r3, [r2, #0]
			prvHeapInit();
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
  400f2e:	2c00      	cmp	r4, #0
  400f30:	d037      	beq.n	400fa2 <pvPortMalloc+0xaa>
		{
			xWantedSize += heapSTRUCT_SIZE;
  400f32:	f104 0210 	add.w	r2, r4, #16

			/* Ensure that blocks are always aligned to the required number of 
			bytes. */
			if( xWantedSize & portBYTE_ALIGNMENT_MASK )
  400f36:	f012 0f07 	tst.w	r2, #7
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  400f3a:	bf1c      	itt	ne
  400f3c:	f022 0207 	bicne.w	r2, r2, #7
  400f40:	3208      	addne	r2, #8
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < xTotalHeapSize ) )
  400f42:	1e51      	subs	r1, r2, #1
  400f44:	f641 73fe 	movw	r3, #8190	; 0x1ffe
  400f48:	4299      	cmp	r1, r3
  400f4a:	d827      	bhi.n	400f9c <pvPortMalloc+0xa4>
		{
			/* Traverse the list from the start	(lowest address) block until one
			of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
  400f4c:	4919      	ldr	r1, [pc, #100]	; (400fb4 <pvPortMalloc+0xbc>)
  400f4e:	680c      	ldr	r4, [r1, #0]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  400f50:	e001      	b.n	400f56 <pvPortMalloc+0x5e>
  400f52:	4621      	mov	r1, r4
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
  400f54:	461c      	mov	r4, r3
		{
			/* Traverse the list from the start	(lowest address) block until one
			of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  400f56:	6863      	ldr	r3, [r4, #4]
  400f58:	429a      	cmp	r2, r3
  400f5a:	d902      	bls.n	400f62 <pvPortMalloc+0x6a>
  400f5c:	6823      	ldr	r3, [r4, #0]
  400f5e:	2b00      	cmp	r3, #0
  400f60:	d1f7      	bne.n	400f52 <pvPortMalloc+0x5a>
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If the end marker was reached then a block of adequate size was
			not found. */
			if( pxBlock != pxEnd )
  400f62:	4b13      	ldr	r3, [pc, #76]	; (400fb0 <pvPortMalloc+0xb8>)
  400f64:	681b      	ldr	r3, [r3, #0]
  400f66:	429c      	cmp	r4, r3
  400f68:	d018      	beq.n	400f9c <pvPortMalloc+0xa4>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
  400f6a:	680d      	ldr	r5, [r1, #0]
  400f6c:	3510      	adds	r5, #16

				/* This block is being returned for use so must be taken out of
				the	list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  400f6e:	6823      	ldr	r3, [r4, #0]
  400f70:	600b      	str	r3, [r1, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  400f72:	6863      	ldr	r3, [r4, #4]
  400f74:	1a9b      	subs	r3, r3, r2
  400f76:	2b20      	cmp	r3, #32
  400f78:	d904      	bls.n	400f84 <pvPortMalloc+0x8c>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
  400f7a:	18a0      	adds	r0, r4, r2

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  400f7c:	6043      	str	r3, [r0, #4]
					pxBlock->xBlockSize = xWantedSize;
  400f7e:	6062      	str	r2, [r4, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
  400f80:	4b0f      	ldr	r3, [pc, #60]	; (400fc0 <pvPortMalloc+0xc8>)
  400f82:	4798      	blx	r3
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
  400f84:	4a0d      	ldr	r2, [pc, #52]	; (400fbc <pvPortMalloc+0xc4>)
  400f86:	6813      	ldr	r3, [r2, #0]
  400f88:	6861      	ldr	r1, [r4, #4]
  400f8a:	1a5b      	subs	r3, r3, r1
  400f8c:	6013      	str	r3, [r2, #0]
			}
		}
	}
	xTaskResumeAll();
  400f8e:	4b0d      	ldr	r3, [pc, #52]	; (400fc4 <pvPortMalloc+0xcc>)
  400f90:	4798      	blx	r3

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
  400f92:	b94d      	cbnz	r5, 400fa8 <pvPortMalloc+0xb0>
		{
			vApplicationMallocFailedHook();
  400f94:	4b0c      	ldr	r3, [pc, #48]	; (400fc8 <pvPortMalloc+0xd0>)
  400f96:	4798      	blx	r3
  400f98:	2500      	movs	r5, #0
		}
	}
	#endif

	return pvReturn;
  400f9a:	e005      	b.n	400fa8 <pvPortMalloc+0xb0>

				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
  400f9c:	4b09      	ldr	r3, [pc, #36]	; (400fc4 <pvPortMalloc+0xcc>)
  400f9e:	4798      	blx	r3
  400fa0:	e7f8      	b.n	400f94 <pvPortMalloc+0x9c>
  400fa2:	4b08      	ldr	r3, [pc, #32]	; (400fc4 <pvPortMalloc+0xcc>)
  400fa4:	4798      	blx	r3
  400fa6:	e7f5      	b.n	400f94 <pvPortMalloc+0x9c>
		}
	}
	#endif

	return pvReturn;
}
  400fa8:	4628      	mov	r0, r5
  400faa:	bd38      	pop	{r3, r4, r5, pc}
  400fac:	00401809 	.word	0x00401809
  400fb0:	20002540 	.word	0x20002540
  400fb4:	20002544 	.word	0x20002544
  400fb8:	20000540 	.word	0x20000540
  400fbc:	20000008 	.word	0x20000008
  400fc0:	00400ea5 	.word	0x00400ea5
  400fc4:	00401959 	.word	0x00401959
  400fc8:	0040222d 	.word	0x0040222d

00400fcc <vPortFree>:
void vPortFree( void *pv )
{
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv != NULL )
  400fcc:	b180      	cbz	r0, 400ff0 <vPortFree+0x24>
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  400fce:	b510      	push	{r4, lr}
  400fd0:	4604      	mov	r4, r0
		puc -= heapSTRUCT_SIZE;

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
  400fd2:	4b08      	ldr	r3, [pc, #32]	; (400ff4 <vPortFree+0x28>)
  400fd4:	4798      	blx	r3
		{
			/* Add this block to the list of free blocks. */
			xFreeBytesRemaining += pxLink->xBlockSize;
  400fd6:	4a08      	ldr	r2, [pc, #32]	; (400ff8 <vPortFree+0x2c>)
  400fd8:	f854 1c0c 	ldr.w	r1, [r4, #-12]
  400fdc:	6813      	ldr	r3, [r2, #0]
  400fde:	440b      	add	r3, r1
  400fe0:	6013      	str	r3, [r2, #0]
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );			
  400fe2:	f1a4 0010 	sub.w	r0, r4, #16
  400fe6:	4b05      	ldr	r3, [pc, #20]	; (400ffc <vPortFree+0x30>)
  400fe8:	4798      	blx	r3
		}
		xTaskResumeAll();
  400fea:	4b05      	ldr	r3, [pc, #20]	; (401000 <vPortFree+0x34>)
  400fec:	4798      	blx	r3
  400fee:	bd10      	pop	{r4, pc}
  400ff0:	4770      	bx	lr
  400ff2:	bf00      	nop
  400ff4:	00401809 	.word	0x00401809
  400ff8:	20000008 	.word	0x20000008
  400ffc:	00400ea5 	.word	0x00400ea5
  401000:	00401959 	.word	0x00401959

00401004 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
  401004:	b510      	push	{r4, lr}
  401006:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
  401008:	6c03      	ldr	r3, [r0, #64]	; 0x40
  40100a:	b93b      	cbnz	r3, 40101c <prvCopyDataToQueue+0x18>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  40100c:	6803      	ldr	r3, [r0, #0]
  40100e:	bb1b      	cbnz	r3, 401058 <prvCopyDataToQueue+0x54>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
  401010:	6840      	ldr	r0, [r0, #4]
  401012:	4b13      	ldr	r3, [pc, #76]	; (401060 <prvCopyDataToQueue+0x5c>)
  401014:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
  401016:	2300      	movs	r3, #0
  401018:	6063      	str	r3, [r4, #4]
  40101a:	e01d      	b.n	401058 <prvCopyDataToQueue+0x54>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
  40101c:	b96a      	cbnz	r2, 40103a <prvCopyDataToQueue+0x36>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
  40101e:	461a      	mov	r2, r3
  401020:	6880      	ldr	r0, [r0, #8]
  401022:	4b10      	ldr	r3, [pc, #64]	; (401064 <prvCopyDataToQueue+0x60>)
  401024:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  401026:	68a2      	ldr	r2, [r4, #8]
  401028:	6c23      	ldr	r3, [r4, #64]	; 0x40
  40102a:	4413      	add	r3, r2
  40102c:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
  40102e:	6862      	ldr	r2, [r4, #4]
  401030:	4293      	cmp	r3, r2
  401032:	d311      	bcc.n	401058 <prvCopyDataToQueue+0x54>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  401034:	6823      	ldr	r3, [r4, #0]
  401036:	60a3      	str	r3, [r4, #8]
  401038:	e00e      	b.n	401058 <prvCopyDataToQueue+0x54>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
  40103a:	461a      	mov	r2, r3
  40103c:	68c0      	ldr	r0, [r0, #12]
  40103e:	4b09      	ldr	r3, [pc, #36]	; (401064 <prvCopyDataToQueue+0x60>)
  401040:	4798      	blx	r3
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
  401042:	6c23      	ldr	r3, [r4, #64]	; 0x40
  401044:	425b      	negs	r3, r3
  401046:	68e2      	ldr	r2, [r4, #12]
  401048:	441a      	add	r2, r3
  40104a:	60e2      	str	r2, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
  40104c:	6821      	ldr	r1, [r4, #0]
  40104e:	428a      	cmp	r2, r1
  401050:	d202      	bcs.n	401058 <prvCopyDataToQueue+0x54>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  401052:	6862      	ldr	r2, [r4, #4]
  401054:	4413      	add	r3, r2
  401056:	60e3      	str	r3, [r4, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
  401058:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  40105a:	3301      	adds	r3, #1
  40105c:	63a3      	str	r3, [r4, #56]	; 0x38
  40105e:	bd10      	pop	{r4, pc}
  401060:	00401e45 	.word	0x00401e45
  401064:	004022dd 	.word	0x004022dd

00401068 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
  401068:	b538      	push	{r3, r4, r5, lr}
  40106a:	4603      	mov	r3, r0
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
  40106c:	6800      	ldr	r0, [r0, #0]
  40106e:	b158      	cbz	r0, 401088 <prvCopyDataFromQueue+0x20>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
  401070:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  401072:	68dc      	ldr	r4, [r3, #12]
  401074:	4414      	add	r4, r2
  401076:	60dc      	str	r4, [r3, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
  401078:	685d      	ldr	r5, [r3, #4]
  40107a:	42ac      	cmp	r4, r5
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
  40107c:	bf28      	it	cs
  40107e:	60d8      	strcs	r0, [r3, #12]
  401080:	4608      	mov	r0, r1
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
  401082:	68d9      	ldr	r1, [r3, #12]
  401084:	4b01      	ldr	r3, [pc, #4]	; (40108c <prvCopyDataFromQueue+0x24>)
  401086:	4798      	blx	r3
  401088:	bd38      	pop	{r3, r4, r5, pc}
  40108a:	bf00      	nop
  40108c:	004022dd 	.word	0x004022dd

00401090 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
  401090:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  401092:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  401094:	4b1e      	ldr	r3, [pc, #120]	; (401110 <prvUnlockQueue+0x80>)
  401096:	4798      	blx	r3
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  401098:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  40109a:	2b00      	cmp	r3, #0
  40109c:	dd13      	ble.n	4010c6 <prvUnlockQueue+0x36>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  40109e:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4010a0:	b91b      	cbnz	r3, 4010aa <prvUnlockQueue+0x1a>
  4010a2:	e010      	b.n	4010c6 <prvUnlockQueue+0x36>
  4010a4:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4010a6:	b923      	cbnz	r3, 4010b2 <prvUnlockQueue+0x22>
  4010a8:	e00d      	b.n	4010c6 <prvUnlockQueue+0x36>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4010aa:	f104 0624 	add.w	r6, r4, #36	; 0x24
  4010ae:	4d19      	ldr	r5, [pc, #100]	; (401114 <prvUnlockQueue+0x84>)
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
  4010b0:	4f19      	ldr	r7, [pc, #100]	; (401118 <prvUnlockQueue+0x88>)
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4010b2:	4630      	mov	r0, r6
  4010b4:	47a8      	blx	r5
  4010b6:	b100      	cbz	r0, 4010ba <prvUnlockQueue+0x2a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
  4010b8:	47b8      	blx	r7
				}

				--( pxQueue->xTxLock );
  4010ba:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4010bc:	3b01      	subs	r3, #1
  4010be:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  4010c0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4010c2:	2b00      	cmp	r3, #0
  4010c4:	dcee      	bgt.n	4010a4 <prvUnlockQueue+0x14>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
  4010c6:	f04f 33ff 	mov.w	r3, #4294967295
  4010ca:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
  4010cc:	4b13      	ldr	r3, [pc, #76]	; (40111c <prvUnlockQueue+0x8c>)
  4010ce:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  4010d0:	4b0f      	ldr	r3, [pc, #60]	; (401110 <prvUnlockQueue+0x80>)
  4010d2:	4798      	blx	r3
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  4010d4:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4010d6:	2b00      	cmp	r3, #0
  4010d8:	dd13      	ble.n	401102 <prvUnlockQueue+0x72>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  4010da:	6923      	ldr	r3, [r4, #16]
  4010dc:	b91b      	cbnz	r3, 4010e6 <prvUnlockQueue+0x56>
  4010de:	e010      	b.n	401102 <prvUnlockQueue+0x72>
  4010e0:	6923      	ldr	r3, [r4, #16]
  4010e2:	b923      	cbnz	r3, 4010ee <prvUnlockQueue+0x5e>
  4010e4:	e00d      	b.n	401102 <prvUnlockQueue+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  4010e6:	f104 0610 	add.w	r6, r4, #16
  4010ea:	4d0a      	ldr	r5, [pc, #40]	; (401114 <prvUnlockQueue+0x84>)
				{
					vTaskMissedYield();
  4010ec:	4f0a      	ldr	r7, [pc, #40]	; (401118 <prvUnlockQueue+0x88>)
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  4010ee:	4630      	mov	r0, r6
  4010f0:	47a8      	blx	r5
  4010f2:	b100      	cbz	r0, 4010f6 <prvUnlockQueue+0x66>
				{
					vTaskMissedYield();
  4010f4:	47b8      	blx	r7
				}

				--( pxQueue->xRxLock );
  4010f6:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4010f8:	3b01      	subs	r3, #1
  4010fa:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  4010fc:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4010fe:	2b00      	cmp	r3, #0
  401100:	dcee      	bgt.n	4010e0 <prvUnlockQueue+0x50>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
  401102:	f04f 33ff 	mov.w	r3, #4294967295
  401106:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
  401108:	4b04      	ldr	r3, [pc, #16]	; (40111c <prvUnlockQueue+0x8c>)
  40110a:	4798      	blx	r3
  40110c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40110e:	bf00      	nop
  401110:	00400db1 	.word	0x00400db1
  401114:	00401c5d 	.word	0x00401c5d
  401118:	00401d8d 	.word	0x00401d8d
  40111c:	00400dd1 	.word	0x00400dd1

00401120 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
  401120:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxQueue );
  401122:	b918      	cbnz	r0, 40112c <xQueueGenericReset+0xc>
  401124:	4b17      	ldr	r3, [pc, #92]	; (401184 <xQueueGenericReset+0x64>)
  401126:	4798      	blx	r3
  401128:	bf00      	nop
  40112a:	e7fd      	b.n	401128 <xQueueGenericReset+0x8>
  40112c:	460d      	mov	r5, r1
  40112e:	4604      	mov	r4, r0

	taskENTER_CRITICAL();
  401130:	4b15      	ldr	r3, [pc, #84]	; (401188 <xQueueGenericReset+0x68>)
  401132:	4798      	blx	r3
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  401134:	6822      	ldr	r2, [r4, #0]
  401136:	6c21      	ldr	r1, [r4, #64]	; 0x40
  401138:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  40113a:	fb03 f301 	mul.w	r3, r3, r1
  40113e:	18d0      	adds	r0, r2, r3
  401140:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  401142:	2000      	movs	r0, #0
  401144:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
  401146:	60a2      	str	r2, [r4, #8]
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
  401148:	1a5b      	subs	r3, r3, r1
  40114a:	4413      	add	r3, r2
  40114c:	60e3      	str	r3, [r4, #12]
		pxQueue->xRxLock = queueUNLOCKED;
  40114e:	f04f 33ff 	mov.w	r3, #4294967295
  401152:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
  401154:	64a3      	str	r3, [r4, #72]	; 0x48

		if( xNewQueue == pdFALSE )
  401156:	b955      	cbnz	r5, 40116e <xQueueGenericReset+0x4e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  401158:	6923      	ldr	r3, [r4, #16]
  40115a:	b17b      	cbz	r3, 40117c <xQueueGenericReset+0x5c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  40115c:	f104 0010 	add.w	r0, r4, #16
  401160:	4b0a      	ldr	r3, [pc, #40]	; (40118c <xQueueGenericReset+0x6c>)
  401162:	4798      	blx	r3
  401164:	2801      	cmp	r0, #1
  401166:	d109      	bne.n	40117c <xQueueGenericReset+0x5c>
				{
					portYIELD_WITHIN_API();
  401168:	4b09      	ldr	r3, [pc, #36]	; (401190 <xQueueGenericReset+0x70>)
  40116a:	4798      	blx	r3
  40116c:	e006      	b.n	40117c <xQueueGenericReset+0x5c>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  40116e:	f104 0010 	add.w	r0, r4, #16
  401172:	4d08      	ldr	r5, [pc, #32]	; (401194 <xQueueGenericReset+0x74>)
  401174:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  401176:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40117a:	47a8      	blx	r5
		}
	}
	taskEXIT_CRITICAL();
  40117c:	4b06      	ldr	r3, [pc, #24]	; (401198 <xQueueGenericReset+0x78>)
  40117e:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
  401180:	2001      	movs	r0, #1
  401182:	bd38      	pop	{r3, r4, r5, pc}
  401184:	00400da1 	.word	0x00400da1
  401188:	00400db1 	.word	0x00400db1
  40118c:	00401c5d 	.word	0x00401c5d
  401190:	00400d91 	.word	0x00400d91
  401194:	00400ca1 	.word	0x00400ca1
  401198:	00400dd1 	.word	0x00400dd1

0040119c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
  40119c:	b570      	push	{r4, r5, r6, lr}
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  40119e:	b198      	cbz	r0, 4011c8 <xQueueGenericCreate+0x2c>
  4011a0:	460d      	mov	r5, r1
  4011a2:	4606      	mov	r6, r0
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  4011a4:	204c      	movs	r0, #76	; 0x4c
  4011a6:	4b0e      	ldr	r3, [pc, #56]	; (4011e0 <xQueueGenericCreate+0x44>)
  4011a8:	4798      	blx	r3
		if( pxNewQueue != NULL )
  4011aa:	4604      	mov	r4, r0
  4011ac:	b160      	cbz	r0, 4011c8 <xQueueGenericCreate+0x2c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
  4011ae:	fb05 f006 	mul.w	r0, r5, r6
  4011b2:	3001      	adds	r0, #1
  4011b4:	4b0a      	ldr	r3, [pc, #40]	; (4011e0 <xQueueGenericCreate+0x44>)
  4011b6:	4798      	blx	r3
  4011b8:	6020      	str	r0, [r4, #0]
			if( pxNewQueue->pcHead != NULL )
  4011ba:	b940      	cbnz	r0, 4011ce <xQueueGenericCreate+0x32>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
  4011bc:	4620      	mov	r0, r4
  4011be:	4b09      	ldr	r3, [pc, #36]	; (4011e4 <xQueueGenericCreate+0x48>)
  4011c0:	4798      	blx	r3
  4011c2:	e001      	b.n	4011c8 <xQueueGenericCreate+0x2c>
			}
		}
	}

	configASSERT( xReturn );
  4011c4:	bf00      	nop
  4011c6:	e7fd      	b.n	4011c4 <xQueueGenericCreate+0x28>
  4011c8:	4b07      	ldr	r3, [pc, #28]	; (4011e8 <xQueueGenericCreate+0x4c>)
  4011ca:	4798      	blx	r3
  4011cc:	e7fa      	b.n	4011c4 <xQueueGenericCreate+0x28>
			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
			if( pxNewQueue->pcHead != NULL )
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
  4011ce:	63e6      	str	r6, [r4, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
  4011d0:	6425      	str	r5, [r4, #64]	; 0x40
				xQueueGenericReset( pxNewQueue, pdTRUE );
  4011d2:	2101      	movs	r1, #1
  4011d4:	4620      	mov	r0, r4
  4011d6:	4b05      	ldr	r3, [pc, #20]	; (4011ec <xQueueGenericCreate+0x50>)
  4011d8:	4798      	blx	r3
	}

	configASSERT( xReturn );

	return xReturn;
}
  4011da:	4620      	mov	r0, r4
  4011dc:	bd70      	pop	{r4, r5, r6, pc}
  4011de:	bf00      	nop
  4011e0:	00400ef9 	.word	0x00400ef9
  4011e4:	00400fcd 	.word	0x00400fcd
  4011e8:	00400da1 	.word	0x00400da1
  4011ec:	00401121 	.word	0x00401121

004011f0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
  4011f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4011f4:	b085      	sub	sp, #20
  4011f6:	9201      	str	r2, [sp, #4]
  4011f8:	9300      	str	r3, [sp, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;

	configASSERT( pxQueue );
  4011fa:	b918      	cbnz	r0, 401204 <xQueueGenericSend+0x14>
  4011fc:	4b38      	ldr	r3, [pc, #224]	; (4012e0 <xQueueGenericSend+0xf0>)
  4011fe:	4798      	blx	r3
  401200:	bf00      	nop
  401202:	e7fd      	b.n	401200 <xQueueGenericSend+0x10>
  401204:	468a      	mov	sl, r1
  401206:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  401208:	b929      	cbnz	r1, 401216 <xQueueGenericSend+0x26>
  40120a:	6c03      	ldr	r3, [r0, #64]	; 0x40
  40120c:	b12b      	cbz	r3, 40121a <xQueueGenericSend+0x2a>
  40120e:	4b34      	ldr	r3, [pc, #208]	; (4012e0 <xQueueGenericSend+0xf0>)
  401210:	4798      	blx	r3
  401212:	bf00      	nop
  401214:	e7fd      	b.n	401212 <xQueueGenericSend+0x22>
  401216:	2700      	movs	r7, #0
  401218:	e000      	b.n	40121c <xQueueGenericSend+0x2c>
  40121a:	2700      	movs	r7, #0
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  40121c:	4e31      	ldr	r6, [pc, #196]	; (4012e4 <xQueueGenericSend+0xf4>)
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  40121e:	f8df b0ec 	ldr.w	fp, [pc, #236]	; 40130c <xQueueGenericSend+0x11c>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
  401222:	4d31      	ldr	r5, [pc, #196]	; (4012e8 <xQueueGenericSend+0xf8>)
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  401224:	47b0      	blx	r6
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
  401226:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  401228:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  40122a:	429a      	cmp	r2, r3
  40122c:	d212      	bcs.n	401254 <xQueueGenericSend+0x64>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  40122e:	9a00      	ldr	r2, [sp, #0]
  401230:	4651      	mov	r1, sl
  401232:	4620      	mov	r0, r4
  401234:	4b2d      	ldr	r3, [pc, #180]	; (4012ec <xQueueGenericSend+0xfc>)
  401236:	4798      	blx	r3

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  401238:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40123a:	b13b      	cbz	r3, 40124c <xQueueGenericSend+0x5c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
  40123c:	f104 0024 	add.w	r0, r4, #36	; 0x24
  401240:	4b2b      	ldr	r3, [pc, #172]	; (4012f0 <xQueueGenericSend+0x100>)
  401242:	4798      	blx	r3
  401244:	2801      	cmp	r0, #1
  401246:	d101      	bne.n	40124c <xQueueGenericSend+0x5c>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
  401248:	4b2a      	ldr	r3, [pc, #168]	; (4012f4 <xQueueGenericSend+0x104>)
  40124a:	4798      	blx	r3
					}
				}

				taskEXIT_CRITICAL();
  40124c:	4b26      	ldr	r3, [pc, #152]	; (4012e8 <xQueueGenericSend+0xf8>)
  40124e:	4798      	blx	r3

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
  401250:	2001      	movs	r0, #1
  401252:	e042      	b.n	4012da <xQueueGenericSend+0xea>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  401254:	9b01      	ldr	r3, [sp, #4]
  401256:	b91b      	cbnz	r3, 401260 <xQueueGenericSend+0x70>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  401258:	4b23      	ldr	r3, [pc, #140]	; (4012e8 <xQueueGenericSend+0xf8>)
  40125a:	4798      	blx	r3

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  40125c:	2000      	movs	r0, #0
  40125e:	e03c      	b.n	4012da <xQueueGenericSend+0xea>
				}
				else if( xEntryTimeSet == pdFALSE )
  401260:	b917      	cbnz	r7, 401268 <xQueueGenericSend+0x78>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  401262:	a802      	add	r0, sp, #8
  401264:	47d8      	blx	fp
					xEntryTimeSet = pdTRUE;
  401266:	2701      	movs	r7, #1
				}
			}
		}
		taskEXIT_CRITICAL();
  401268:	47a8      	blx	r5

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  40126a:	4b23      	ldr	r3, [pc, #140]	; (4012f8 <xQueueGenericSend+0x108>)
  40126c:	4798      	blx	r3
		prvLockQueue( pxQueue );
  40126e:	47b0      	blx	r6
  401270:	6c63      	ldr	r3, [r4, #68]	; 0x44
  401272:	f1b3 3fff 	cmp.w	r3, #4294967295
  401276:	bf04      	itt	eq
  401278:	2300      	moveq	r3, #0
  40127a:	6463      	streq	r3, [r4, #68]	; 0x44
  40127c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  40127e:	f1b3 3fff 	cmp.w	r3, #4294967295
  401282:	bf04      	itt	eq
  401284:	2300      	moveq	r3, #0
  401286:	64a3      	streq	r3, [r4, #72]	; 0x48
  401288:	47a8      	blx	r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  40128a:	a901      	add	r1, sp, #4
  40128c:	a802      	add	r0, sp, #8
  40128e:	4b1b      	ldr	r3, [pc, #108]	; (4012fc <xQueueGenericSend+0x10c>)
  401290:	4798      	blx	r3
  401292:	b9e0      	cbnz	r0, 4012ce <xQueueGenericSend+0xde>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  401294:	47b0      	blx	r6
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  401296:	f8d4 9038 	ldr.w	r9, [r4, #56]	; 0x38
  40129a:	f8d4 803c 	ldr.w	r8, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
  40129e:	47a8      	blx	r5
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
  4012a0:	45c1      	cmp	r9, r8
  4012a2:	d10e      	bne.n	4012c2 <xQueueGenericSend+0xd2>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  4012a4:	9901      	ldr	r1, [sp, #4]
  4012a6:	f104 0010 	add.w	r0, r4, #16
  4012aa:	4b15      	ldr	r3, [pc, #84]	; (401300 <xQueueGenericSend+0x110>)
  4012ac:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  4012ae:	4620      	mov	r0, r4
  4012b0:	4b14      	ldr	r3, [pc, #80]	; (401304 <xQueueGenericSend+0x114>)
  4012b2:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
  4012b4:	4b14      	ldr	r3, [pc, #80]	; (401308 <xQueueGenericSend+0x118>)
  4012b6:	4798      	blx	r3
  4012b8:	2800      	cmp	r0, #0
  4012ba:	d1b3      	bne.n	401224 <xQueueGenericSend+0x34>
				{
					portYIELD_WITHIN_API();
  4012bc:	4b0d      	ldr	r3, [pc, #52]	; (4012f4 <xQueueGenericSend+0x104>)
  4012be:	4798      	blx	r3
  4012c0:	e7b0      	b.n	401224 <xQueueGenericSend+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  4012c2:	4620      	mov	r0, r4
  4012c4:	4b0f      	ldr	r3, [pc, #60]	; (401304 <xQueueGenericSend+0x114>)
  4012c6:	4798      	blx	r3
				( void ) xTaskResumeAll();
  4012c8:	4b0f      	ldr	r3, [pc, #60]	; (401308 <xQueueGenericSend+0x118>)
  4012ca:	4798      	blx	r3
  4012cc:	e7aa      	b.n	401224 <xQueueGenericSend+0x34>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  4012ce:	4620      	mov	r0, r4
  4012d0:	4b0c      	ldr	r3, [pc, #48]	; (401304 <xQueueGenericSend+0x114>)
  4012d2:	4798      	blx	r3
			( void ) xTaskResumeAll();
  4012d4:	4b0c      	ldr	r3, [pc, #48]	; (401308 <xQueueGenericSend+0x118>)
  4012d6:	4798      	blx	r3

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  4012d8:	2000      	movs	r0, #0
		}
	}
}
  4012da:	b005      	add	sp, #20
  4012dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4012e0:	00400da1 	.word	0x00400da1
  4012e4:	00400db1 	.word	0x00400db1
  4012e8:	00400dd1 	.word	0x00400dd1
  4012ec:	00401005 	.word	0x00401005
  4012f0:	00401c5d 	.word	0x00401c5d
  4012f4:	00400d91 	.word	0x00400d91
  4012f8:	00401809 	.word	0x00401809
  4012fc:	00401d09 	.word	0x00401d09
  401300:	00401bb9 	.word	0x00401bb9
  401304:	00401091 	.word	0x00401091
  401308:	00401959 	.word	0x00401959
  40130c:	00401ce1 	.word	0x00401ce1

00401310 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
  401310:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
  401314:	b918      	cbnz	r0, 40131e <xQueueGenericSendFromISR+0xe>
  401316:	4b1e      	ldr	r3, [pc, #120]	; (401390 <xQueueGenericSendFromISR+0x80>)
  401318:	4798      	blx	r3
  40131a:	bf00      	nop
  40131c:	e7fd      	b.n	40131a <xQueueGenericSendFromISR+0xa>
  40131e:	460e      	mov	r6, r1
  401320:	4615      	mov	r5, r2
  401322:	4698      	mov	r8, r3
  401324:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  401326:	b929      	cbnz	r1, 401334 <xQueueGenericSendFromISR+0x24>
  401328:	6c03      	ldr	r3, [r0, #64]	; 0x40
  40132a:	b11b      	cbz	r3, 401334 <xQueueGenericSendFromISR+0x24>
  40132c:	4b18      	ldr	r3, [pc, #96]	; (401390 <xQueueGenericSendFromISR+0x80>)
  40132e:	4798      	blx	r3
  401330:	bf00      	nop
  401332:	e7fd      	b.n	401330 <xQueueGenericSendFromISR+0x20>
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  401334:	4b16      	ldr	r3, [pc, #88]	; (401390 <xQueueGenericSendFromISR+0x80>)
  401336:	4798      	blx	r3
  401338:	4607      	mov	r7, r0
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
  40133a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  40133c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  40133e:	429a      	cmp	r2, r3
  401340:	d218      	bcs.n	401374 <xQueueGenericSendFromISR+0x64>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  401342:	4642      	mov	r2, r8
  401344:	4631      	mov	r1, r6
  401346:	4620      	mov	r0, r4
  401348:	4b12      	ldr	r3, [pc, #72]	; (401394 <xQueueGenericSendFromISR+0x84>)
  40134a:	4798      	blx	r3

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
  40134c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  40134e:	f1b3 3fff 	cmp.w	r3, #4294967295
  401352:	d10a      	bne.n	40136a <xQueueGenericSendFromISR+0x5a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  401354:	6a63      	ldr	r3, [r4, #36]	; 0x24
  401356:	b17b      	cbz	r3, 401378 <xQueueGenericSendFromISR+0x68>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  401358:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40135c:	4b0e      	ldr	r3, [pc, #56]	; (401398 <xQueueGenericSendFromISR+0x88>)
  40135e:	4798      	blx	r3
  401360:	b160      	cbz	r0, 40137c <xQueueGenericSendFromISR+0x6c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
  401362:	b16d      	cbz	r5, 401380 <xQueueGenericSendFromISR+0x70>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
  401364:	2401      	movs	r4, #1
  401366:	602c      	str	r4, [r5, #0]
  401368:	e00b      	b.n	401382 <xQueueGenericSendFromISR+0x72>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
  40136a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  40136c:	3301      	adds	r3, #1
  40136e:	64a3      	str	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
  401370:	2401      	movs	r4, #1
  401372:	e006      	b.n	401382 <xQueueGenericSendFromISR+0x72>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  401374:	2400      	movs	r4, #0
  401376:	e004      	b.n	401382 <xQueueGenericSendFromISR+0x72>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
  401378:	2401      	movs	r4, #1
  40137a:	e002      	b.n	401382 <xQueueGenericSendFromISR+0x72>
  40137c:	2401      	movs	r4, #1
  40137e:	e000      	b.n	401382 <xQueueGenericSendFromISR+0x72>
  401380:	2401      	movs	r4, #1
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  401382:	4638      	mov	r0, r7
  401384:	4b05      	ldr	r3, [pc, #20]	; (40139c <xQueueGenericSendFromISR+0x8c>)
  401386:	4798      	blx	r3

	return xReturn;
}
  401388:	4620      	mov	r0, r4
  40138a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40138e:	bf00      	nop
  401390:	00400da1 	.word	0x00400da1
  401394:	00401005 	.word	0x00401005
  401398:	00401c5d 	.word	0x00401c5d
  40139c:	00400dc9 	.word	0x00400dc9

004013a0 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
  4013a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4013a4:	b085      	sub	sp, #20
  4013a6:	9201      	str	r2, [sp, #4]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;

	configASSERT( pxQueue );
  4013a8:	b918      	cbnz	r0, 4013b2 <xQueueGenericReceive+0x12>
  4013aa:	4b46      	ldr	r3, [pc, #280]	; (4014c4 <xQueueGenericReceive+0x124>)
  4013ac:	4798      	blx	r3
  4013ae:	bf00      	nop
  4013b0:	e7fd      	b.n	4013ae <xQueueGenericReceive+0xe>
  4013b2:	4689      	mov	r9, r1
  4013b4:	469a      	mov	sl, r3
  4013b6:	4604      	mov	r4, r0
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  4013b8:	b929      	cbnz	r1, 4013c6 <xQueueGenericReceive+0x26>
  4013ba:	6c03      	ldr	r3, [r0, #64]	; 0x40
  4013bc:	b12b      	cbz	r3, 4013ca <xQueueGenericReceive+0x2a>
  4013be:	4b41      	ldr	r3, [pc, #260]	; (4014c4 <xQueueGenericReceive+0x124>)
  4013c0:	4798      	blx	r3
  4013c2:	bf00      	nop
  4013c4:	e7fd      	b.n	4013c2 <xQueueGenericReceive+0x22>
  4013c6:	2700      	movs	r7, #0
  4013c8:	e000      	b.n	4013cc <xQueueGenericReceive+0x2c>
  4013ca:	2700      	movs	r7, #0
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
  4013cc:	4e3e      	ldr	r6, [pc, #248]	; (4014c8 <xQueueGenericReceive+0x128>)
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  4013ce:	f8df b128 	ldr.w	fp, [pc, #296]	; 4014f8 <xQueueGenericReceive+0x158>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
  4013d2:	4d3e      	ldr	r5, [pc, #248]	; (4014cc <xQueueGenericReceive+0x12c>)
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
  4013d4:	47b0      	blx	r6
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
  4013d6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  4013d8:	b343      	cbz	r3, 40142c <xQueueGenericReceive+0x8c>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
  4013da:	68e5      	ldr	r5, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  4013dc:	4649      	mov	r1, r9
  4013de:	4620      	mov	r0, r4
  4013e0:	4b3b      	ldr	r3, [pc, #236]	; (4014d0 <xQueueGenericReceive+0x130>)
  4013e2:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
  4013e4:	f1ba 0f00 	cmp.w	sl, #0
  4013e8:	d112      	bne.n	401410 <xQueueGenericReceive+0x70>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
  4013ea:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  4013ec:	3b01      	subs	r3, #1
  4013ee:	63a3      	str	r3, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  4013f0:	6823      	ldr	r3, [r4, #0]
  4013f2:	b913      	cbnz	r3, 4013fa <xQueueGenericReceive+0x5a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
  4013f4:	4b37      	ldr	r3, [pc, #220]	; (4014d4 <xQueueGenericReceive+0x134>)
  4013f6:	4798      	blx	r3
  4013f8:	6060      	str	r0, [r4, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  4013fa:	6923      	ldr	r3, [r4, #16]
  4013fc:	b193      	cbz	r3, 401424 <xQueueGenericReceive+0x84>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  4013fe:	f104 0010 	add.w	r0, r4, #16
  401402:	4b35      	ldr	r3, [pc, #212]	; (4014d8 <xQueueGenericReceive+0x138>)
  401404:	4798      	blx	r3
  401406:	2801      	cmp	r0, #1
  401408:	d10c      	bne.n	401424 <xQueueGenericReceive+0x84>
						{
							portYIELD_WITHIN_API();
  40140a:	4b34      	ldr	r3, [pc, #208]	; (4014dc <xQueueGenericReceive+0x13c>)
  40140c:	4798      	blx	r3
  40140e:	e009      	b.n	401424 <xQueueGenericReceive+0x84>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
  401410:	60e5      	str	r5, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  401412:	6a63      	ldr	r3, [r4, #36]	; 0x24
  401414:	b133      	cbz	r3, 401424 <xQueueGenericReceive+0x84>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  401416:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40141a:	4b2f      	ldr	r3, [pc, #188]	; (4014d8 <xQueueGenericReceive+0x138>)
  40141c:	4798      	blx	r3
  40141e:	b108      	cbz	r0, 401424 <xQueueGenericReceive+0x84>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
  401420:	4b2e      	ldr	r3, [pc, #184]	; (4014dc <xQueueGenericReceive+0x13c>)
  401422:	4798      	blx	r3
						}
					}
				}

				taskEXIT_CRITICAL();
  401424:	4b29      	ldr	r3, [pc, #164]	; (4014cc <xQueueGenericReceive+0x12c>)
  401426:	4798      	blx	r3
				return pdPASS;
  401428:	2001      	movs	r0, #1
  40142a:	e048      	b.n	4014be <xQueueGenericReceive+0x11e>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  40142c:	9b01      	ldr	r3, [sp, #4]
  40142e:	b91b      	cbnz	r3, 401438 <xQueueGenericReceive+0x98>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  401430:	4b26      	ldr	r3, [pc, #152]	; (4014cc <xQueueGenericReceive+0x12c>)
  401432:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  401434:	2000      	movs	r0, #0
  401436:	e042      	b.n	4014be <xQueueGenericReceive+0x11e>
				}
				else if( xEntryTimeSet == pdFALSE )
  401438:	b917      	cbnz	r7, 401440 <xQueueGenericReceive+0xa0>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  40143a:	a802      	add	r0, sp, #8
  40143c:	47d8      	blx	fp
					xEntryTimeSet = pdTRUE;
  40143e:	2701      	movs	r7, #1
				}
			}
		}
		taskEXIT_CRITICAL();
  401440:	47a8      	blx	r5

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  401442:	4b27      	ldr	r3, [pc, #156]	; (4014e0 <xQueueGenericReceive+0x140>)
  401444:	4798      	blx	r3
		prvLockQueue( pxQueue );
  401446:	47b0      	blx	r6
  401448:	6c63      	ldr	r3, [r4, #68]	; 0x44
  40144a:	f1b3 3fff 	cmp.w	r3, #4294967295
  40144e:	bf04      	itt	eq
  401450:	2300      	moveq	r3, #0
  401452:	6463      	streq	r3, [r4, #68]	; 0x44
  401454:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  401456:	f1b3 3fff 	cmp.w	r3, #4294967295
  40145a:	bf04      	itt	eq
  40145c:	2300      	moveq	r3, #0
  40145e:	64a3      	streq	r3, [r4, #72]	; 0x48
  401460:	47a8      	blx	r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  401462:	a901      	add	r1, sp, #4
  401464:	a802      	add	r0, sp, #8
  401466:	4b1f      	ldr	r3, [pc, #124]	; (4014e4 <xQueueGenericReceive+0x144>)
  401468:	4798      	blx	r3
  40146a:	bb10      	cbnz	r0, 4014b2 <xQueueGenericReceive+0x112>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  40146c:	47b0      	blx	r6
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
  40146e:	f8d4 8038 	ldr.w	r8, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
  401472:	47a8      	blx	r5
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  401474:	f1b8 0f00 	cmp.w	r8, #0
  401478:	d115      	bne.n	4014a6 <xQueueGenericReceive+0x106>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  40147a:	6823      	ldr	r3, [r4, #0]
  40147c:	b923      	cbnz	r3, 401488 <xQueueGenericReceive+0xe8>
					{
						portENTER_CRITICAL();
  40147e:	47b0      	blx	r6
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
  401480:	6860      	ldr	r0, [r4, #4]
  401482:	4b19      	ldr	r3, [pc, #100]	; (4014e8 <xQueueGenericReceive+0x148>)
  401484:	4798      	blx	r3
						}
						portEXIT_CRITICAL();
  401486:	47a8      	blx	r5
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  401488:	9901      	ldr	r1, [sp, #4]
  40148a:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40148e:	4b17      	ldr	r3, [pc, #92]	; (4014ec <xQueueGenericReceive+0x14c>)
  401490:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  401492:	4620      	mov	r0, r4
  401494:	4b16      	ldr	r3, [pc, #88]	; (4014f0 <xQueueGenericReceive+0x150>)
  401496:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
  401498:	4b16      	ldr	r3, [pc, #88]	; (4014f4 <xQueueGenericReceive+0x154>)
  40149a:	4798      	blx	r3
  40149c:	2800      	cmp	r0, #0
  40149e:	d199      	bne.n	4013d4 <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
  4014a0:	4b0e      	ldr	r3, [pc, #56]	; (4014dc <xQueueGenericReceive+0x13c>)
  4014a2:	4798      	blx	r3
  4014a4:	e796      	b.n	4013d4 <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  4014a6:	4620      	mov	r0, r4
  4014a8:	4b11      	ldr	r3, [pc, #68]	; (4014f0 <xQueueGenericReceive+0x150>)
  4014aa:	4798      	blx	r3
				( void ) xTaskResumeAll();
  4014ac:	4b11      	ldr	r3, [pc, #68]	; (4014f4 <xQueueGenericReceive+0x154>)
  4014ae:	4798      	blx	r3
  4014b0:	e790      	b.n	4013d4 <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
  4014b2:	4620      	mov	r0, r4
  4014b4:	4b0e      	ldr	r3, [pc, #56]	; (4014f0 <xQueueGenericReceive+0x150>)
  4014b6:	4798      	blx	r3
			( void ) xTaskResumeAll();
  4014b8:	4b0e      	ldr	r3, [pc, #56]	; (4014f4 <xQueueGenericReceive+0x154>)
  4014ba:	4798      	blx	r3
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
  4014bc:	2000      	movs	r0, #0
		}
	}
}
  4014be:	b005      	add	sp, #20
  4014c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4014c4:	00400da1 	.word	0x00400da1
  4014c8:	00400db1 	.word	0x00400db1
  4014cc:	00400dd1 	.word	0x00400dd1
  4014d0:	00401069 	.word	0x00401069
  4014d4:	00401d99 	.word	0x00401d99
  4014d8:	00401c5d 	.word	0x00401c5d
  4014dc:	00400d91 	.word	0x00400d91
  4014e0:	00401809 	.word	0x00401809
  4014e4:	00401d09 	.word	0x00401d09
  4014e8:	00401dc5 	.word	0x00401dc5
  4014ec:	00401bb9 	.word	0x00401bb9
  4014f0:	00401091 	.word	0x00401091
  4014f4:	00401959 	.word	0x00401959
  4014f8:	00401ce1 	.word	0x00401ce1

004014fc <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
  4014fc:	b538      	push	{r3, r4, r5, lr}
  4014fe:	4604      	mov	r4, r0
  401500:	460d      	mov	r5, r1
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
  401502:	4b0d      	ldr	r3, [pc, #52]	; (401538 <vQueueWaitForMessageRestricted+0x3c>)
  401504:	4798      	blx	r3
  401506:	6c63      	ldr	r3, [r4, #68]	; 0x44
  401508:	f1b3 3fff 	cmp.w	r3, #4294967295
  40150c:	bf04      	itt	eq
  40150e:	2300      	moveq	r3, #0
  401510:	6463      	streq	r3, [r4, #68]	; 0x44
  401512:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  401514:	f1b3 3fff 	cmp.w	r3, #4294967295
  401518:	bf04      	itt	eq
  40151a:	2300      	moveq	r3, #0
  40151c:	64a3      	streq	r3, [r4, #72]	; 0x48
  40151e:	4b07      	ldr	r3, [pc, #28]	; (40153c <vQueueWaitForMessageRestricted+0x40>)
  401520:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
  401522:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  401524:	b923      	cbnz	r3, 401530 <vQueueWaitForMessageRestricted+0x34>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  401526:	4629      	mov	r1, r5
  401528:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40152c:	4b04      	ldr	r3, [pc, #16]	; (401540 <vQueueWaitForMessageRestricted+0x44>)
  40152e:	4798      	blx	r3
		}
		prvUnlockQueue( pxQueue );
  401530:	4620      	mov	r0, r4
  401532:	4b04      	ldr	r3, [pc, #16]	; (401544 <vQueueWaitForMessageRestricted+0x48>)
  401534:	4798      	blx	r3
  401536:	bd38      	pop	{r3, r4, r5, pc}
  401538:	00400db1 	.word	0x00400db1
  40153c:	00400dd1 	.word	0x00400dd1
  401540:	00401c19 	.word	0x00401c19
  401544:	00401091 	.word	0x00401091

00401548 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
  401548:	b510      	push	{r4, lr}
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  40154a:	4b0f      	ldr	r3, [pc, #60]	; (401588 <prvAddCurrentTaskToDelayedList+0x40>)
  40154c:	681b      	ldr	r3, [r3, #0]
  40154e:	6058      	str	r0, [r3, #4]

	if( xTimeToWake < xTickCount )
  401550:	4b0e      	ldr	r3, [pc, #56]	; (40158c <prvAddCurrentTaskToDelayedList+0x44>)
  401552:	681b      	ldr	r3, [r3, #0]
  401554:	4298      	cmp	r0, r3
  401556:	d207      	bcs.n	401568 <prvAddCurrentTaskToDelayedList+0x20>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  401558:	4b0d      	ldr	r3, [pc, #52]	; (401590 <prvAddCurrentTaskToDelayedList+0x48>)
  40155a:	6818      	ldr	r0, [r3, #0]
  40155c:	4b0a      	ldr	r3, [pc, #40]	; (401588 <prvAddCurrentTaskToDelayedList+0x40>)
  40155e:	6819      	ldr	r1, [r3, #0]
  401560:	3104      	adds	r1, #4
  401562:	4b0c      	ldr	r3, [pc, #48]	; (401594 <prvAddCurrentTaskToDelayedList+0x4c>)
  401564:	4798      	blx	r3
  401566:	bd10      	pop	{r4, pc}
  401568:	4604      	mov	r4, r0
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  40156a:	4b0b      	ldr	r3, [pc, #44]	; (401598 <prvAddCurrentTaskToDelayedList+0x50>)
  40156c:	6818      	ldr	r0, [r3, #0]
  40156e:	4b06      	ldr	r3, [pc, #24]	; (401588 <prvAddCurrentTaskToDelayedList+0x40>)
  401570:	6819      	ldr	r1, [r3, #0]
  401572:	3104      	adds	r1, #4
  401574:	4b07      	ldr	r3, [pc, #28]	; (401594 <prvAddCurrentTaskToDelayedList+0x4c>)
  401576:	4798      	blx	r3

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
  401578:	4b08      	ldr	r3, [pc, #32]	; (40159c <prvAddCurrentTaskToDelayedList+0x54>)
  40157a:	681b      	ldr	r3, [r3, #0]
  40157c:	429c      	cmp	r4, r3
		{
			xNextTaskUnblockTime = xTimeToWake;
  40157e:	bf3c      	itt	cc
  401580:	4b06      	ldrcc	r3, [pc, #24]	; (40159c <prvAddCurrentTaskToDelayedList+0x54>)
  401582:	601c      	strcc	r4, [r3, #0]
  401584:	bd10      	pop	{r4, pc}
  401586:	bf00      	nop
  401588:	20002600 	.word	0x20002600
  40158c:	2000261c 	.word	0x2000261c
  401590:	20002620 	.word	0x20002620
  401594:	00400cdd 	.word	0x00400cdd
  401598:	20002564 	.word	0x20002564
  40159c:	2000000c 	.word	0x2000000c

004015a0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
  4015a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4015a4:	b083      	sub	sp, #12
  4015a6:	9f0c      	ldr	r7, [sp, #48]	; 0x30
  4015a8:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
  4015ac:	9e0e      	ldr	r6, [sp, #56]	; 0x38
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	configASSERT( pxTaskCode );
  4015ae:	9001      	str	r0, [sp, #4]
  4015b0:	b918      	cbnz	r0, 4015ba <xTaskGenericCreate+0x1a>
  4015b2:	4b61      	ldr	r3, [pc, #388]	; (401738 <xTaskGenericCreate+0x198>)
  4015b4:	4798      	blx	r3
  4015b6:	bf00      	nop
  4015b8:	e7fd      	b.n	4015b6 <xTaskGenericCreate+0x16>
  4015ba:	4689      	mov	r9, r1
  4015bc:	4615      	mov	r5, r2
  4015be:	469b      	mov	fp, r3
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
  4015c0:	2f04      	cmp	r7, #4
  4015c2:	d903      	bls.n	4015cc <xTaskGenericCreate+0x2c>
  4015c4:	4b5c      	ldr	r3, [pc, #368]	; (401738 <xTaskGenericCreate+0x198>)
  4015c6:	4798      	blx	r3
  4015c8:	bf00      	nop
  4015ca:	e7fd      	b.n	4015c8 <xTaskGenericCreate+0x28>
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
  4015cc:	2044      	movs	r0, #68	; 0x44
  4015ce:	4b5b      	ldr	r3, [pc, #364]	; (40173c <xTaskGenericCreate+0x19c>)
  4015d0:	4798      	blx	r3

	if( pxNewTCB != NULL )
  4015d2:	4604      	mov	r4, r0
  4015d4:	2800      	cmp	r0, #0
  4015d6:	f000 80aa 	beq.w	40172e <xTaskGenericCreate+0x18e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
  4015da:	2e00      	cmp	r6, #0
  4015dc:	f040 80a4 	bne.w	401728 <xTaskGenericCreate+0x188>
  4015e0:	00a8      	lsls	r0, r5, #2
  4015e2:	4b56      	ldr	r3, [pc, #344]	; (40173c <xTaskGenericCreate+0x19c>)
  4015e4:	4798      	blx	r3
  4015e6:	6320      	str	r0, [r4, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
  4015e8:	b918      	cbnz	r0, 4015f2 <xTaskGenericCreate+0x52>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
  4015ea:	4620      	mov	r0, r4
  4015ec:	4b54      	ldr	r3, [pc, #336]	; (401740 <xTaskGenericCreate+0x1a0>)
  4015ee:	4798      	blx	r3
  4015f0:	e09d      	b.n	40172e <xTaskGenericCreate+0x18e>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
  4015f2:	00aa      	lsls	r2, r5, #2
  4015f4:	21a5      	movs	r1, #165	; 0xa5
  4015f6:	4b53      	ldr	r3, [pc, #332]	; (401744 <xTaskGenericCreate+0x1a4>)
  4015f8:	4798      	blx	r3
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
  4015fa:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
  4015fe:	3d01      	subs	r5, #1
  401600:	6b23      	ldr	r3, [r4, #48]	; 0x30
  401602:	eb03 0385 	add.w	r3, r3, r5, lsl #2
  401606:	f023 0507 	bic.w	r5, r3, #7
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
  40160a:	220c      	movs	r2, #12
  40160c:	4649      	mov	r1, r9
  40160e:	f104 0034 	add.w	r0, r4, #52	; 0x34
  401612:	4b4d      	ldr	r3, [pc, #308]	; (401748 <xTaskGenericCreate+0x1a8>)
  401614:	4798      	blx	r3
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
  401616:	2300      	movs	r3, #0
  401618:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
  40161c:	463e      	mov	r6, r7
  40161e:	2f04      	cmp	r7, #4
  401620:	bf28      	it	cs
  401622:	2604      	movcs	r6, #4
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
  401624:	62e6      	str	r6, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
  401626:	6426      	str	r6, [r4, #64]	; 0x40
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
  401628:	f104 0904 	add.w	r9, r4, #4
  40162c:	4648      	mov	r0, r9
  40162e:	f8df a168 	ldr.w	sl, [pc, #360]	; 401798 <xTaskGenericCreate+0x1f8>
  401632:	47d0      	blx	sl
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
  401634:	f104 0018 	add.w	r0, r4, #24
  401638:	47d0      	blx	sl

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
  40163a:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
  40163c:	f1c6 0605 	rsb	r6, r6, #5
  401640:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
  401642:	6264      	str	r4, [r4, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  401644:	465a      	mov	r2, fp
  401646:	9901      	ldr	r1, [sp, #4]
  401648:	4628      	mov	r0, r5
  40164a:	4b40      	ldr	r3, [pc, #256]	; (40174c <xTaskGenericCreate+0x1ac>)
  40164c:	4798      	blx	r3
  40164e:	6020      	str	r0, [r4, #0]
		}
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
  401650:	f010 0f07 	tst.w	r0, #7
  401654:	d003      	beq.n	40165e <xTaskGenericCreate+0xbe>
  401656:	4b38      	ldr	r3, [pc, #224]	; (401738 <xTaskGenericCreate+0x198>)
  401658:	4798      	blx	r3
  40165a:	bf00      	nop
  40165c:	e7fd      	b.n	40165a <xTaskGenericCreate+0xba>

		if( ( void * ) pxCreatedTask != NULL )
  40165e:	f1b8 0f00 	cmp.w	r8, #0
  401662:	d001      	beq.n	401668 <xTaskGenericCreate+0xc8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
  401664:	f8c8 4000 	str.w	r4, [r8]
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
  401668:	4b39      	ldr	r3, [pc, #228]	; (401750 <xTaskGenericCreate+0x1b0>)
  40166a:	4798      	blx	r3
		{
			uxCurrentNumberOfTasks++;
  40166c:	4a39      	ldr	r2, [pc, #228]	; (401754 <xTaskGenericCreate+0x1b4>)
  40166e:	6813      	ldr	r3, [r2, #0]
  401670:	3301      	adds	r3, #1
  401672:	6013      	str	r3, [r2, #0]
			if( pxCurrentTCB == NULL )
  401674:	4b38      	ldr	r3, [pc, #224]	; (401758 <xTaskGenericCreate+0x1b8>)
  401676:	681b      	ldr	r3, [r3, #0]
  401678:	bb0b      	cbnz	r3, 4016be <xTaskGenericCreate+0x11e>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
  40167a:	4b37      	ldr	r3, [pc, #220]	; (401758 <xTaskGenericCreate+0x1b8>)
  40167c:	601c      	str	r4, [r3, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
  40167e:	6813      	ldr	r3, [r2, #0]
  401680:	2b01      	cmp	r3, #1
  401682:	d126      	bne.n	4016d2 <xTaskGenericCreate+0x132>
  401684:	4d35      	ldr	r5, [pc, #212]	; (40175c <xTaskGenericCreate+0x1bc>)
  401686:	f105 0864 	add.w	r8, r5, #100	; 0x64
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
  40168a:	4e35      	ldr	r6, [pc, #212]	; (401760 <xTaskGenericCreate+0x1c0>)
  40168c:	4628      	mov	r0, r5
  40168e:	47b0      	blx	r6
  401690:	3514      	adds	r5, #20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
  401692:	4545      	cmp	r5, r8
  401694:	d1fa      	bne.n	40168c <xTaskGenericCreate+0xec>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
  401696:	f8df 8104 	ldr.w	r8, [pc, #260]	; 40179c <xTaskGenericCreate+0x1fc>
  40169a:	4640      	mov	r0, r8
  40169c:	4d30      	ldr	r5, [pc, #192]	; (401760 <xTaskGenericCreate+0x1c0>)
  40169e:	47a8      	blx	r5
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
  4016a0:	4e30      	ldr	r6, [pc, #192]	; (401764 <xTaskGenericCreate+0x1c4>)
  4016a2:	4630      	mov	r0, r6
  4016a4:	47a8      	blx	r5
	vListInitialise( ( xList * ) &xPendingReadyList );
  4016a6:	4830      	ldr	r0, [pc, #192]	; (401768 <xTaskGenericCreate+0x1c8>)
  4016a8:	47a8      	blx	r5

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
  4016aa:	4830      	ldr	r0, [pc, #192]	; (40176c <xTaskGenericCreate+0x1cc>)
  4016ac:	47a8      	blx	r5
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
  4016ae:	4830      	ldr	r0, [pc, #192]	; (401770 <xTaskGenericCreate+0x1d0>)
  4016b0:	47a8      	blx	r5
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  4016b2:	4b30      	ldr	r3, [pc, #192]	; (401774 <xTaskGenericCreate+0x1d4>)
  4016b4:	f8c3 8000 	str.w	r8, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  4016b8:	4b2f      	ldr	r3, [pc, #188]	; (401778 <xTaskGenericCreate+0x1d8>)
  4016ba:	601e      	str	r6, [r3, #0]
  4016bc:	e009      	b.n	4016d2 <xTaskGenericCreate+0x132>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
  4016be:	4b2f      	ldr	r3, [pc, #188]	; (40177c <xTaskGenericCreate+0x1dc>)
  4016c0:	681b      	ldr	r3, [r3, #0]
  4016c2:	b933      	cbnz	r3, 4016d2 <xTaskGenericCreate+0x132>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
  4016c4:	4b24      	ldr	r3, [pc, #144]	; (401758 <xTaskGenericCreate+0x1b8>)
  4016c6:	681b      	ldr	r3, [r3, #0]
  4016c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4016ca:	429f      	cmp	r7, r3
					{
						pxCurrentTCB = pxNewTCB;
  4016cc:	bf24      	itt	cs
  4016ce:	4b22      	ldrcs	r3, [pc, #136]	; (401758 <xTaskGenericCreate+0x1b8>)
  4016d0:	601c      	strcs	r4, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
  4016d2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  4016d4:	4b2a      	ldr	r3, [pc, #168]	; (401780 <xTaskGenericCreate+0x1e0>)
  4016d6:	681b      	ldr	r3, [r3, #0]
  4016d8:	4298      	cmp	r0, r3
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
  4016da:	bf84      	itt	hi
  4016dc:	4b28      	ldrhi	r3, [pc, #160]	; (401780 <xTaskGenericCreate+0x1e0>)
  4016de:	6018      	strhi	r0, [r3, #0]
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
  4016e0:	4a28      	ldr	r2, [pc, #160]	; (401784 <xTaskGenericCreate+0x1e4>)
  4016e2:	6813      	ldr	r3, [r2, #0]
  4016e4:	3301      	adds	r3, #1
  4016e6:	6013      	str	r3, [r2, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
  4016e8:	4b27      	ldr	r3, [pc, #156]	; (401788 <xTaskGenericCreate+0x1e8>)
  4016ea:	681b      	ldr	r3, [r3, #0]
  4016ec:	4298      	cmp	r0, r3
  4016ee:	bf84      	itt	hi
  4016f0:	4b25      	ldrhi	r3, [pc, #148]	; (401788 <xTaskGenericCreate+0x1e8>)
  4016f2:	6018      	strhi	r0, [r3, #0]
  4016f4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  4016f8:	4649      	mov	r1, r9
  4016fa:	4b18      	ldr	r3, [pc, #96]	; (40175c <xTaskGenericCreate+0x1bc>)
  4016fc:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  401700:	4b22      	ldr	r3, [pc, #136]	; (40178c <xTaskGenericCreate+0x1ec>)
  401702:	4798      	blx	r3

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
  401704:	4b22      	ldr	r3, [pc, #136]	; (401790 <xTaskGenericCreate+0x1f0>)
  401706:	4798      	blx	r3
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
  401708:	4b1c      	ldr	r3, [pc, #112]	; (40177c <xTaskGenericCreate+0x1dc>)
  40170a:	681b      	ldr	r3, [r3, #0]
  40170c:	b143      	cbz	r3, 401720 <xTaskGenericCreate+0x180>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
  40170e:	4b12      	ldr	r3, [pc, #72]	; (401758 <xTaskGenericCreate+0x1b8>)
  401710:	681b      	ldr	r3, [r3, #0]
  401712:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401714:	429f      	cmp	r7, r3
  401716:	d905      	bls.n	401724 <xTaskGenericCreate+0x184>
			{
				portYIELD_WITHIN_API();
  401718:	4b1e      	ldr	r3, [pc, #120]	; (401794 <xTaskGenericCreate+0x1f4>)
  40171a:	4798      	blx	r3
  40171c:	2001      	movs	r0, #1
  40171e:	e008      	b.n	401732 <xTaskGenericCreate+0x192>
  401720:	2001      	movs	r0, #1
  401722:	e006      	b.n	401732 <xTaskGenericCreate+0x192>
  401724:	2001      	movs	r0, #1
  401726:	e004      	b.n	401732 <xTaskGenericCreate+0x192>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
  401728:	6306      	str	r6, [r0, #48]	; 0x30
  40172a:	4630      	mov	r0, r6
  40172c:	e761      	b.n	4015f2 <xTaskGenericCreate+0x52>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  40172e:	f04f 30ff 	mov.w	r0, #4294967295
			}
		}
	}

	return xReturn;
}
  401732:	b003      	add	sp, #12
  401734:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  401738:	00400da1 	.word	0x00400da1
  40173c:	00400ef9 	.word	0x00400ef9
  401740:	00400fcd 	.word	0x00400fcd
  401744:	00402411 	.word	0x00402411
  401748:	004024ad 	.word	0x004024ad
  40174c:	00400d55 	.word	0x00400d55
  401750:	00400db1 	.word	0x00400db1
  401754:	20002644 	.word	0x20002644
  401758:	20002600 	.word	0x20002600
  40175c:	20002598 	.word	0x20002598
  401760:	00400ca1 	.word	0x00400ca1
  401764:	20002584 	.word	0x20002584
  401768:	20002604 	.word	0x20002604
  40176c:	20002570 	.word	0x20002570
  401770:	20002550 	.word	0x20002550
  401774:	20002564 	.word	0x20002564
  401778:	20002620 	.word	0x20002620
  40177c:	20002568 	.word	0x20002568
  401780:	20002648 	.word	0x20002648
  401784:	20002628 	.word	0x20002628
  401788:	20002624 	.word	0x20002624
  40178c:	00400cc1 	.word	0x00400cc1
  401790:	00400dd1 	.word	0x00400dd1
  401794:	00400d91 	.word	0x00400d91
  401798:	00400cb9 	.word	0x00400cb9
  40179c:	2000262c 	.word	0x2000262c

004017a0 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
  4017a0:	b510      	push	{r4, lr}
  4017a2:	b084      	sub	sp, #16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
  4017a4:	2300      	movs	r3, #0
  4017a6:	9303      	str	r3, [sp, #12]
  4017a8:	9302      	str	r3, [sp, #8]
  4017aa:	9301      	str	r3, [sp, #4]
  4017ac:	9300      	str	r3, [sp, #0]
  4017ae:	2264      	movs	r2, #100	; 0x64
  4017b0:	490d      	ldr	r1, [pc, #52]	; (4017e8 <vTaskStartScheduler+0x48>)
  4017b2:	480e      	ldr	r0, [pc, #56]	; (4017ec <vTaskStartScheduler+0x4c>)
  4017b4:	4c0e      	ldr	r4, [pc, #56]	; (4017f0 <vTaskStartScheduler+0x50>)
  4017b6:	47a0      	blx	r4
	}
	#endif

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
  4017b8:	2801      	cmp	r0, #1
  4017ba:	d10e      	bne.n	4017da <vTaskStartScheduler+0x3a>
		{
			xReturn = xTimerCreateTimerTask();
  4017bc:	4b0d      	ldr	r3, [pc, #52]	; (4017f4 <vTaskStartScheduler+0x54>)
  4017be:	4798      	blx	r3
		}
	}
	#endif

	if( xReturn == pdPASS )
  4017c0:	2801      	cmp	r0, #1
  4017c2:	d10a      	bne.n	4017da <vTaskStartScheduler+0x3a>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
  4017c4:	4b0c      	ldr	r3, [pc, #48]	; (4017f8 <vTaskStartScheduler+0x58>)
  4017c6:	4798      	blx	r3

		xSchedulerRunning = pdTRUE;
  4017c8:	2201      	movs	r2, #1
  4017ca:	4b0c      	ldr	r3, [pc, #48]	; (4017fc <vTaskStartScheduler+0x5c>)
  4017cc:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0U;
  4017ce:	2200      	movs	r2, #0
  4017d0:	4b0b      	ldr	r3, [pc, #44]	; (401800 <vTaskStartScheduler+0x60>)
  4017d2:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
  4017d4:	4b0b      	ldr	r3, [pc, #44]	; (401804 <vTaskStartScheduler+0x64>)
  4017d6:	4798      	blx	r3
  4017d8:	e004      	b.n	4017e4 <vTaskStartScheduler+0x44>
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
  4017da:	b918      	cbnz	r0, 4017e4 <vTaskStartScheduler+0x44>
  4017dc:	4b06      	ldr	r3, [pc, #24]	; (4017f8 <vTaskStartScheduler+0x58>)
  4017de:	4798      	blx	r3
  4017e0:	bf00      	nop
  4017e2:	e7fd      	b.n	4017e0 <vTaskStartScheduler+0x40>
}
  4017e4:	b004      	add	sp, #16
  4017e6:	bd10      	pop	{r4, pc}
  4017e8:	00402640 	.word	0x00402640
  4017ec:	00401aa5 	.word	0x00401aa5
  4017f0:	004015a1 	.word	0x004015a1
  4017f4:	00401f3d 	.word	0x00401f3d
  4017f8:	00400da1 	.word	0x00400da1
  4017fc:	20002568 	.word	0x20002568
  401800:	2000261c 	.word	0x2000261c
  401804:	00400e6d 	.word	0x00400e6d

00401808 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  401808:	4a02      	ldr	r2, [pc, #8]	; (401814 <vTaskSuspendAll+0xc>)
  40180a:	6813      	ldr	r3, [r2, #0]
  40180c:	3301      	adds	r3, #1
  40180e:	6013      	str	r3, [r2, #0]
  401810:	4770      	bx	lr
  401812:	bf00      	nop
  401814:	200025fc 	.word	0x200025fc

00401818 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
  401818:	b510      	push	{r4, lr}
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
  40181a:	4b04      	ldr	r3, [pc, #16]	; (40182c <xTaskGetTickCount+0x14>)
  40181c:	4798      	blx	r3
	{
		xTicks = xTickCount;
  40181e:	4b04      	ldr	r3, [pc, #16]	; (401830 <xTaskGetTickCount+0x18>)
  401820:	681c      	ldr	r4, [r3, #0]
	}
	taskEXIT_CRITICAL();
  401822:	4b04      	ldr	r3, [pc, #16]	; (401834 <xTaskGetTickCount+0x1c>)
  401824:	4798      	blx	r3

	return xTicks;
}
  401826:	4620      	mov	r0, r4
  401828:	bd10      	pop	{r4, pc}
  40182a:	bf00      	nop
  40182c:	00400db1 	.word	0x00400db1
  401830:	2000261c 	.word	0x2000261c
  401834:	00400dd1 	.word	0x00400dd1

00401838 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
  401838:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  40183c:	4b3a      	ldr	r3, [pc, #232]	; (401928 <vTaskIncrementTick+0xf0>)
  40183e:	681b      	ldr	r3, [r3, #0]
  401840:	2b00      	cmp	r3, #0
  401842:	d16b      	bne.n	40191c <vTaskIncrementTick+0xe4>
	{
		++xTickCount;
  401844:	4b39      	ldr	r3, [pc, #228]	; (40192c <vTaskIncrementTick+0xf4>)
  401846:	681a      	ldr	r2, [r3, #0]
  401848:	3201      	adds	r2, #1
  40184a:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0U )
  40184c:	681b      	ldr	r3, [r3, #0]
  40184e:	bb03      	cbnz	r3, 401892 <vTaskIncrementTick+0x5a>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
  401850:	4b37      	ldr	r3, [pc, #220]	; (401930 <vTaskIncrementTick+0xf8>)
  401852:	681b      	ldr	r3, [r3, #0]
  401854:	681b      	ldr	r3, [r3, #0]
  401856:	b11b      	cbz	r3, 401860 <vTaskIncrementTick+0x28>
  401858:	4b36      	ldr	r3, [pc, #216]	; (401934 <vTaskIncrementTick+0xfc>)
  40185a:	4798      	blx	r3
  40185c:	bf00      	nop
  40185e:	e7fd      	b.n	40185c <vTaskIncrementTick+0x24>

			pxTemp = pxDelayedTaskList;
  401860:	4b33      	ldr	r3, [pc, #204]	; (401930 <vTaskIncrementTick+0xf8>)
  401862:	6819      	ldr	r1, [r3, #0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  401864:	4a34      	ldr	r2, [pc, #208]	; (401938 <vTaskIncrementTick+0x100>)
  401866:	6810      	ldr	r0, [r2, #0]
  401868:	6018      	str	r0, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
  40186a:	6011      	str	r1, [r2, #0]
			xNumOfOverflows++;
  40186c:	4933      	ldr	r1, [pc, #204]	; (40193c <vTaskIncrementTick+0x104>)
  40186e:	680a      	ldr	r2, [r1, #0]
  401870:	3201      	adds	r2, #1
  401872:	600a      	str	r2, [r1, #0]

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  401874:	681b      	ldr	r3, [r3, #0]
  401876:	681b      	ldr	r3, [r3, #0]
  401878:	b923      	cbnz	r3, 401884 <vTaskIncrementTick+0x4c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
  40187a:	f04f 32ff 	mov.w	r2, #4294967295
  40187e:	4b30      	ldr	r3, [pc, #192]	; (401940 <vTaskIncrementTick+0x108>)
  401880:	601a      	str	r2, [r3, #0]
  401882:	e006      	b.n	401892 <vTaskIncrementTick+0x5a>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  401884:	4b2a      	ldr	r3, [pc, #168]	; (401930 <vTaskIncrementTick+0xf8>)
  401886:	681b      	ldr	r3, [r3, #0]
  401888:	68db      	ldr	r3, [r3, #12]
  40188a:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  40188c:	685a      	ldr	r2, [r3, #4]
  40188e:	4b2c      	ldr	r3, [pc, #176]	; (401940 <vTaskIncrementTick+0x108>)
  401890:	601a      	str	r2, [r3, #0]
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  401892:	4b26      	ldr	r3, [pc, #152]	; (40192c <vTaskIncrementTick+0xf4>)
  401894:	681a      	ldr	r2, [r3, #0]
  401896:	4b2a      	ldr	r3, [pc, #168]	; (401940 <vTaskIncrementTick+0x108>)
  401898:	681b      	ldr	r3, [r3, #0]
  40189a:	429a      	cmp	r2, r3
  40189c:	d342      	bcc.n	401924 <vTaskIncrementTick+0xec>
  40189e:	4b24      	ldr	r3, [pc, #144]	; (401930 <vTaskIncrementTick+0xf8>)
  4018a0:	681b      	ldr	r3, [r3, #0]
  4018a2:	681b      	ldr	r3, [r3, #0]
  4018a4:	b16b      	cbz	r3, 4018c2 <vTaskIncrementTick+0x8a>
  4018a6:	4b22      	ldr	r3, [pc, #136]	; (401930 <vTaskIncrementTick+0xf8>)
  4018a8:	681b      	ldr	r3, [r3, #0]
  4018aa:	68db      	ldr	r3, [r3, #12]
  4018ac:	68dc      	ldr	r4, [r3, #12]
  4018ae:	6863      	ldr	r3, [r4, #4]
  4018b0:	4a1e      	ldr	r2, [pc, #120]	; (40192c <vTaskIncrementTick+0xf4>)
  4018b2:	6812      	ldr	r2, [r2, #0]
  4018b4:	4293      	cmp	r3, r2
  4018b6:	d813      	bhi.n	4018e0 <vTaskIncrementTick+0xa8>
  4018b8:	4e22      	ldr	r6, [pc, #136]	; (401944 <vTaskIncrementTick+0x10c>)
  4018ba:	4f23      	ldr	r7, [pc, #140]	; (401948 <vTaskIncrementTick+0x110>)
  4018bc:	f8df 8094 	ldr.w	r8, [pc, #148]	; 401954 <vTaskIncrementTick+0x11c>
  4018c0:	e012      	b.n	4018e8 <vTaskIncrementTick+0xb0>
  4018c2:	f04f 32ff 	mov.w	r2, #4294967295
  4018c6:	4b1e      	ldr	r3, [pc, #120]	; (401940 <vTaskIncrementTick+0x108>)
  4018c8:	601a      	str	r2, [r3, #0]
  4018ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4018ce:	4b18      	ldr	r3, [pc, #96]	; (401930 <vTaskIncrementTick+0xf8>)
  4018d0:	681b      	ldr	r3, [r3, #0]
  4018d2:	68db      	ldr	r3, [r3, #12]
  4018d4:	68dc      	ldr	r4, [r3, #12]
  4018d6:	6863      	ldr	r3, [r4, #4]
  4018d8:	4a14      	ldr	r2, [pc, #80]	; (40192c <vTaskIncrementTick+0xf4>)
  4018da:	6812      	ldr	r2, [r2, #0]
  4018dc:	4293      	cmp	r3, r2
  4018de:	d903      	bls.n	4018e8 <vTaskIncrementTick+0xb0>
  4018e0:	4a17      	ldr	r2, [pc, #92]	; (401940 <vTaskIncrementTick+0x108>)
  4018e2:	6013      	str	r3, [r2, #0]
  4018e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4018e8:	1d25      	adds	r5, r4, #4
  4018ea:	4628      	mov	r0, r5
  4018ec:	47b0      	blx	r6
  4018ee:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  4018f0:	b113      	cbz	r3, 4018f8 <vTaskIncrementTick+0xc0>
  4018f2:	f104 0018 	add.w	r0, r4, #24
  4018f6:	47b0      	blx	r6
  4018f8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  4018fa:	683b      	ldr	r3, [r7, #0]
  4018fc:	4298      	cmp	r0, r3
  4018fe:	bf88      	it	hi
  401900:	6038      	strhi	r0, [r7, #0]
  401902:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  401906:	4629      	mov	r1, r5
  401908:	eb08 0080 	add.w	r0, r8, r0, lsl #2
  40190c:	4b0f      	ldr	r3, [pc, #60]	; (40194c <vTaskIncrementTick+0x114>)
  40190e:	4798      	blx	r3
  401910:	4b07      	ldr	r3, [pc, #28]	; (401930 <vTaskIncrementTick+0xf8>)
  401912:	681b      	ldr	r3, [r3, #0]
  401914:	681b      	ldr	r3, [r3, #0]
  401916:	2b00      	cmp	r3, #0
  401918:	d1d9      	bne.n	4018ce <vTaskIncrementTick+0x96>
  40191a:	e7d2      	b.n	4018c2 <vTaskIncrementTick+0x8a>
	}
	else
	{
		++uxMissedTicks;
  40191c:	4a0c      	ldr	r2, [pc, #48]	; (401950 <vTaskIncrementTick+0x118>)
  40191e:	6813      	ldr	r3, [r2, #0]
  401920:	3301      	adds	r3, #1
  401922:	6013      	str	r3, [r2, #0]
  401924:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401928:	200025fc 	.word	0x200025fc
  40192c:	2000261c 	.word	0x2000261c
  401930:	20002564 	.word	0x20002564
  401934:	00400da1 	.word	0x00400da1
  401938:	20002620 	.word	0x20002620
  40193c:	20002618 	.word	0x20002618
  401940:	2000000c 	.word	0x2000000c
  401944:	00400d19 	.word	0x00400d19
  401948:	20002624 	.word	0x20002624
  40194c:	00400cc1 	.word	0x00400cc1
  401950:	2000254c 	.word	0x2000254c
  401954:	20002598 	.word	0x20002598

00401958 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
  401958:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
  40195c:	4b30      	ldr	r3, [pc, #192]	; (401a20 <xTaskResumeAll+0xc8>)
  40195e:	681b      	ldr	r3, [r3, #0]
  401960:	b91b      	cbnz	r3, 40196a <xTaskResumeAll+0x12>
  401962:	4b30      	ldr	r3, [pc, #192]	; (401a24 <xTaskResumeAll+0xcc>)
  401964:	4798      	blx	r3
  401966:	bf00      	nop
  401968:	e7fd      	b.n	401966 <xTaskResumeAll+0xe>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  40196a:	4b2f      	ldr	r3, [pc, #188]	; (401a28 <xTaskResumeAll+0xd0>)
  40196c:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
  40196e:	4b2c      	ldr	r3, [pc, #176]	; (401a20 <xTaskResumeAll+0xc8>)
  401970:	681a      	ldr	r2, [r3, #0]
  401972:	3a01      	subs	r2, #1
  401974:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  401976:	681b      	ldr	r3, [r3, #0]
  401978:	2b00      	cmp	r3, #0
  40197a:	d149      	bne.n	401a10 <xTaskResumeAll+0xb8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
  40197c:	4b2b      	ldr	r3, [pc, #172]	; (401a2c <xTaskResumeAll+0xd4>)
  40197e:	681b      	ldr	r3, [r3, #0]
  401980:	bb03      	cbnz	r3, 4019c4 <xTaskResumeAll+0x6c>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
  401982:	2400      	movs	r4, #0
  401984:	e047      	b.n	401a16 <xTaskResumeAll+0xbe>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
  401986:	f8d8 300c 	ldr.w	r3, [r8, #12]
  40198a:	68dc      	ldr	r4, [r3, #12]
					uxListRemove( &( pxTCB->xEventListItem ) );
  40198c:	f104 0018 	add.w	r0, r4, #24
  401990:	47b8      	blx	r7
					uxListRemove( &( pxTCB->xGenericListItem ) );
  401992:	f104 0904 	add.w	r9, r4, #4
  401996:	4648      	mov	r0, r9
  401998:	47b8      	blx	r7
					prvAddTaskToReadyQueue( pxTCB );
  40199a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  40199c:	6833      	ldr	r3, [r6, #0]
  40199e:	4298      	cmp	r0, r3
  4019a0:	bf88      	it	hi
  4019a2:	6030      	strhi	r0, [r6, #0]
  4019a4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  4019a8:	4649      	mov	r1, r9
  4019aa:	4b21      	ldr	r3, [pc, #132]	; (401a30 <xTaskResumeAll+0xd8>)
  4019ac:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  4019b0:	4b20      	ldr	r3, [pc, #128]	; (401a34 <xTaskResumeAll+0xdc>)
  4019b2:	4798      	blx	r3

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  4019b4:	4b20      	ldr	r3, [pc, #128]	; (401a38 <xTaskResumeAll+0xe0>)
  4019b6:	681b      	ldr	r3, [r3, #0]
  4019b8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  4019ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					{
						xYieldRequired = pdTRUE;
  4019bc:	429a      	cmp	r2, r3
  4019be:	bf28      	it	cs
  4019c0:	2501      	movcs	r5, #1
  4019c2:	e004      	b.n	4019ce <xTaskResumeAll+0x76>
  4019c4:	2500      	movs	r5, #0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  4019c6:	f8df 8090 	ldr.w	r8, [pc, #144]	; 401a58 <xTaskResumeAll+0x100>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					uxListRemove( &( pxTCB->xEventListItem ) );
  4019ca:	4f1c      	ldr	r7, [pc, #112]	; (401a3c <xTaskResumeAll+0xe4>)
					uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
  4019cc:	4e1c      	ldr	r6, [pc, #112]	; (401a40 <xTaskResumeAll+0xe8>)
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  4019ce:	f8d8 3000 	ldr.w	r3, [r8]
  4019d2:	2b00      	cmp	r3, #0
  4019d4:	d1d7      	bne.n	401986 <xTaskResumeAll+0x2e>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  4019d6:	4b1b      	ldr	r3, [pc, #108]	; (401a44 <xTaskResumeAll+0xec>)
  4019d8:	681b      	ldr	r3, [r3, #0]
  4019da:	b163      	cbz	r3, 4019f6 <xTaskResumeAll+0x9e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  4019dc:	4b19      	ldr	r3, [pc, #100]	; (401a44 <xTaskResumeAll+0xec>)
  4019de:	681b      	ldr	r3, [r3, #0]
  4019e0:	b17b      	cbz	r3, 401a02 <xTaskResumeAll+0xaa>
					{
						vTaskIncrementTick();
  4019e2:	4d19      	ldr	r5, [pc, #100]	; (401a48 <xTaskResumeAll+0xf0>)
						--uxMissedTicks;
  4019e4:	4c17      	ldr	r4, [pc, #92]	; (401a44 <xTaskResumeAll+0xec>)
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
  4019e6:	47a8      	blx	r5
						--uxMissedTicks;
  4019e8:	6823      	ldr	r3, [r4, #0]
  4019ea:	3b01      	subs	r3, #1
  4019ec:	6023      	str	r3, [r4, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  4019ee:	6823      	ldr	r3, [r4, #0]
  4019f0:	2b00      	cmp	r3, #0
  4019f2:	d1f8      	bne.n	4019e6 <xTaskResumeAll+0x8e>
  4019f4:	e005      	b.n	401a02 <xTaskResumeAll+0xaa>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
  4019f6:	2d01      	cmp	r5, #1
  4019f8:	d003      	beq.n	401a02 <xTaskResumeAll+0xaa>
  4019fa:	4b14      	ldr	r3, [pc, #80]	; (401a4c <xTaskResumeAll+0xf4>)
  4019fc:	681b      	ldr	r3, [r3, #0]
  4019fe:	2b01      	cmp	r3, #1
  401a00:	d108      	bne.n	401a14 <xTaskResumeAll+0xbc>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
  401a02:	2200      	movs	r2, #0
  401a04:	4b11      	ldr	r3, [pc, #68]	; (401a4c <xTaskResumeAll+0xf4>)
  401a06:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
  401a08:	4b11      	ldr	r3, [pc, #68]	; (401a50 <xTaskResumeAll+0xf8>)
  401a0a:	4798      	blx	r3
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
  401a0c:	2401      	movs	r4, #1
  401a0e:	e002      	b.n	401a16 <xTaskResumeAll+0xbe>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
  401a10:	2400      	movs	r4, #0
  401a12:	e000      	b.n	401a16 <xTaskResumeAll+0xbe>
  401a14:	2400      	movs	r4, #0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
  401a16:	4b0f      	ldr	r3, [pc, #60]	; (401a54 <xTaskResumeAll+0xfc>)
  401a18:	4798      	blx	r3

	return xAlreadyYielded;
}
  401a1a:	4620      	mov	r0, r4
  401a1c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  401a20:	200025fc 	.word	0x200025fc
  401a24:	00400da1 	.word	0x00400da1
  401a28:	00400db1 	.word	0x00400db1
  401a2c:	20002644 	.word	0x20002644
  401a30:	20002598 	.word	0x20002598
  401a34:	00400cc1 	.word	0x00400cc1
  401a38:	20002600 	.word	0x20002600
  401a3c:	00400d19 	.word	0x00400d19
  401a40:	20002624 	.word	0x20002624
  401a44:	2000254c 	.word	0x2000254c
  401a48:	00401839 	.word	0x00401839
  401a4c:	20002640 	.word	0x20002640
  401a50:	00400d91 	.word	0x00400d91
  401a54:	00400dd1 	.word	0x00400dd1
  401a58:	20002604 	.word	0x20002604

00401a5c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
  401a5c:	b510      	push	{r4, lr}
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
  401a5e:	b180      	cbz	r0, 401a82 <vTaskDelay+0x26>
  401a60:	4604      	mov	r4, r0
		{
			vTaskSuspendAll();
  401a62:	4b09      	ldr	r3, [pc, #36]	; (401a88 <vTaskDelay+0x2c>)
  401a64:	4798      	blx	r3
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
  401a66:	4b09      	ldr	r3, [pc, #36]	; (401a8c <vTaskDelay+0x30>)
  401a68:	681b      	ldr	r3, [r3, #0]
  401a6a:	441c      	add	r4, r3

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
  401a6c:	4b08      	ldr	r3, [pc, #32]	; (401a90 <vTaskDelay+0x34>)
  401a6e:	6818      	ldr	r0, [r3, #0]
  401a70:	3004      	adds	r0, #4
  401a72:	4b08      	ldr	r3, [pc, #32]	; (401a94 <vTaskDelay+0x38>)
  401a74:	4798      	blx	r3
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
  401a76:	4620      	mov	r0, r4
  401a78:	4b07      	ldr	r3, [pc, #28]	; (401a98 <vTaskDelay+0x3c>)
  401a7a:	4798      	blx	r3
			}
			xAlreadyYielded = xTaskResumeAll();
  401a7c:	4b07      	ldr	r3, [pc, #28]	; (401a9c <vTaskDelay+0x40>)
  401a7e:	4798      	blx	r3
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
  401a80:	b908      	cbnz	r0, 401a86 <vTaskDelay+0x2a>
		{
			portYIELD_WITHIN_API();
  401a82:	4b07      	ldr	r3, [pc, #28]	; (401aa0 <vTaskDelay+0x44>)
  401a84:	4798      	blx	r3
  401a86:	bd10      	pop	{r4, pc}
  401a88:	00401809 	.word	0x00401809
  401a8c:	2000261c 	.word	0x2000261c
  401a90:	20002600 	.word	0x20002600
  401a94:	00400d19 	.word	0x00400d19
  401a98:	00401549 	.word	0x00401549
  401a9c:	00401959 	.word	0x00401959
  401aa0:	00400d91 	.word	0x00400d91

00401aa4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
  401aa4:	b580      	push	{r7, lr}
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
  401aa6:	4d12      	ldr	r5, [pc, #72]	; (401af0 <prvIdleTask+0x4c>)
		{
			vTaskSuspendAll();
  401aa8:	f8df 8060 	ldr.w	r8, [pc, #96]	; 401b0c <prvIdleTask+0x68>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  401aac:	4f11      	ldr	r7, [pc, #68]	; (401af4 <prvIdleTask+0x50>)
			xTaskResumeAll();
  401aae:	4e12      	ldr	r6, [pc, #72]	; (401af8 <prvIdleTask+0x54>)
  401ab0:	e019      	b.n	401ae6 <prvIdleTask+0x42>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
  401ab2:	47c0      	blx	r8
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  401ab4:	683c      	ldr	r4, [r7, #0]
			xTaskResumeAll();
  401ab6:	47b0      	blx	r6

			if( xListIsEmpty == pdFALSE )
  401ab8:	b1ac      	cbz	r4, 401ae6 <prvIdleTask+0x42>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
  401aba:	4b10      	ldr	r3, [pc, #64]	; (401afc <prvIdleTask+0x58>)
  401abc:	4798      	blx	r3
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
  401abe:	68fb      	ldr	r3, [r7, #12]
  401ac0:	68dc      	ldr	r4, [r3, #12]
					uxListRemove( &( pxTCB->xGenericListItem ) );
  401ac2:	1d20      	adds	r0, r4, #4
  401ac4:	4b0e      	ldr	r3, [pc, #56]	; (401b00 <prvIdleTask+0x5c>)
  401ac6:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
  401ac8:	4a0e      	ldr	r2, [pc, #56]	; (401b04 <prvIdleTask+0x60>)
  401aca:	6813      	ldr	r3, [r2, #0]
  401acc:	3b01      	subs	r3, #1
  401ace:	6013      	str	r3, [r2, #0]
					--uxTasksDeleted;
  401ad0:	682b      	ldr	r3, [r5, #0]
  401ad2:	3b01      	subs	r3, #1
  401ad4:	602b      	str	r3, [r5, #0]
				}
				taskEXIT_CRITICAL();
  401ad6:	4b0c      	ldr	r3, [pc, #48]	; (401b08 <prvIdleTask+0x64>)
  401ad8:	4798      	blx	r3
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
  401ada:	6b20      	ldr	r0, [r4, #48]	; 0x30
  401adc:	f8df 9030 	ldr.w	r9, [pc, #48]	; 401b10 <prvIdleTask+0x6c>
  401ae0:	47c8      	blx	r9
		vPortFree( pxTCB );
  401ae2:	4620      	mov	r0, r4
  401ae4:	47c8      	blx	r9
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
  401ae6:	682b      	ldr	r3, [r5, #0]
  401ae8:	2b00      	cmp	r3, #0
  401aea:	d1e2      	bne.n	401ab2 <prvIdleTask+0xe>
  401aec:	e7df      	b.n	401aae <prvIdleTask+0xa>
  401aee:	bf00      	nop
  401af0:	2000256c 	.word	0x2000256c
  401af4:	20002570 	.word	0x20002570
  401af8:	00401959 	.word	0x00401959
  401afc:	00400db1 	.word	0x00400db1
  401b00:	00400d19 	.word	0x00400d19
  401b04:	20002644 	.word	0x20002644
  401b08:	00400dd1 	.word	0x00400dd1
  401b0c:	00401809 	.word	0x00401809
  401b10:	00400fcd 	.word	0x00400fcd

00401b14 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  401b14:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
  401b16:	4b22      	ldr	r3, [pc, #136]	; (401ba0 <vTaskSwitchContext+0x8c>)
  401b18:	681b      	ldr	r3, [r3, #0]
  401b1a:	b96b      	cbnz	r3, 401b38 <vTaskSwitchContext+0x24>
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
  401b1c:	4b21      	ldr	r3, [pc, #132]	; (401ba4 <vTaskSwitchContext+0x90>)
  401b1e:	681b      	ldr	r3, [r3, #0]
  401b20:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  401b24:	009b      	lsls	r3, r3, #2
  401b26:	4a20      	ldr	r2, [pc, #128]	; (401ba8 <vTaskSwitchContext+0x94>)
  401b28:	58d3      	ldr	r3, [r2, r3]
  401b2a:	b9cb      	cbnz	r3, 401b60 <vTaskSwitchContext+0x4c>
  401b2c:	4b1d      	ldr	r3, [pc, #116]	; (401ba4 <vTaskSwitchContext+0x90>)
  401b2e:	681b      	ldr	r3, [r3, #0]
  401b30:	b143      	cbz	r3, 401b44 <vTaskSwitchContext+0x30>
  401b32:	4a1c      	ldr	r2, [pc, #112]	; (401ba4 <vTaskSwitchContext+0x90>)
  401b34:	491c      	ldr	r1, [pc, #112]	; (401ba8 <vTaskSwitchContext+0x94>)
  401b36:	e009      	b.n	401b4c <vTaskSwitchContext+0x38>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
  401b38:	2201      	movs	r2, #1
  401b3a:	4b1c      	ldr	r3, [pc, #112]	; (401bac <vTaskSwitchContext+0x98>)
  401b3c:	601a      	str	r2, [r3, #0]
  401b3e:	bd10      	pop	{r4, pc}
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
  401b40:	6813      	ldr	r3, [r2, #0]
  401b42:	b91b      	cbnz	r3, 401b4c <vTaskSwitchContext+0x38>
  401b44:	4b1a      	ldr	r3, [pc, #104]	; (401bb0 <vTaskSwitchContext+0x9c>)
  401b46:	4798      	blx	r3
  401b48:	bf00      	nop
  401b4a:	e7fd      	b.n	401b48 <vTaskSwitchContext+0x34>
  401b4c:	6813      	ldr	r3, [r2, #0]
  401b4e:	3b01      	subs	r3, #1
  401b50:	6013      	str	r3, [r2, #0]
  401b52:	6813      	ldr	r3, [r2, #0]
  401b54:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  401b58:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
  401b5c:	2b00      	cmp	r3, #0
  401b5e:	d0ef      	beq.n	401b40 <vTaskSwitchContext+0x2c>
  401b60:	4b10      	ldr	r3, [pc, #64]	; (401ba4 <vTaskSwitchContext+0x90>)
  401b62:	681b      	ldr	r3, [r3, #0]
  401b64:	4a10      	ldr	r2, [pc, #64]	; (401ba8 <vTaskSwitchContext+0x94>)
  401b66:	0099      	lsls	r1, r3, #2
  401b68:	18c8      	adds	r0, r1, r3
  401b6a:	eb02 0080 	add.w	r0, r2, r0, lsl #2
  401b6e:	6844      	ldr	r4, [r0, #4]
  401b70:	6864      	ldr	r4, [r4, #4]
  401b72:	6044      	str	r4, [r0, #4]
  401b74:	4602      	mov	r2, r0
  401b76:	3208      	adds	r2, #8
  401b78:	4294      	cmp	r4, r2
  401b7a:	d106      	bne.n	401b8a <vTaskSwitchContext+0x76>
  401b7c:	6860      	ldr	r0, [r4, #4]
  401b7e:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  401b82:	4a09      	ldr	r2, [pc, #36]	; (401ba8 <vTaskSwitchContext+0x94>)
  401b84:	eb02 0281 	add.w	r2, r2, r1, lsl #2
  401b88:	6050      	str	r0, [r2, #4]
  401b8a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  401b8e:	4a06      	ldr	r2, [pc, #24]	; (401ba8 <vTaskSwitchContext+0x94>)
  401b90:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  401b94:	685b      	ldr	r3, [r3, #4]
  401b96:	68da      	ldr	r2, [r3, #12]
  401b98:	4b06      	ldr	r3, [pc, #24]	; (401bb4 <vTaskSwitchContext+0xa0>)
  401b9a:	601a      	str	r2, [r3, #0]
  401b9c:	bd10      	pop	{r4, pc}
  401b9e:	bf00      	nop
  401ba0:	200025fc 	.word	0x200025fc
  401ba4:	20002624 	.word	0x20002624
  401ba8:	20002598 	.word	0x20002598
  401bac:	20002640 	.word	0x20002640
  401bb0:	00400da1 	.word	0x00400da1
  401bb4:	20002600 	.word	0x20002600

00401bb8 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
  401bb8:	b538      	push	{r3, r4, r5, lr}
portTickType xTimeToWake;

	configASSERT( pxEventList );
  401bba:	b918      	cbnz	r0, 401bc4 <vTaskPlaceOnEventList+0xc>
  401bbc:	4b0e      	ldr	r3, [pc, #56]	; (401bf8 <vTaskPlaceOnEventList+0x40>)
  401bbe:	4798      	blx	r3
  401bc0:	bf00      	nop
  401bc2:	e7fd      	b.n	401bc0 <vTaskPlaceOnEventList+0x8>
  401bc4:	460c      	mov	r4, r1
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  401bc6:	4d0d      	ldr	r5, [pc, #52]	; (401bfc <vTaskPlaceOnEventList+0x44>)
  401bc8:	6829      	ldr	r1, [r5, #0]
  401bca:	3118      	adds	r1, #24
  401bcc:	4b0c      	ldr	r3, [pc, #48]	; (401c00 <vTaskPlaceOnEventList+0x48>)
  401bce:	4798      	blx	r3

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
  401bd0:	6828      	ldr	r0, [r5, #0]
  401bd2:	3004      	adds	r0, #4
  401bd4:	4b0b      	ldr	r3, [pc, #44]	; (401c04 <vTaskPlaceOnEventList+0x4c>)
  401bd6:	4798      	blx	r3
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
  401bd8:	f1b4 3fff 	cmp.w	r4, #4294967295
  401bdc:	d105      	bne.n	401bea <vTaskPlaceOnEventList+0x32>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  401bde:	6829      	ldr	r1, [r5, #0]
  401be0:	3104      	adds	r1, #4
  401be2:	4809      	ldr	r0, [pc, #36]	; (401c08 <vTaskPlaceOnEventList+0x50>)
  401be4:	4b09      	ldr	r3, [pc, #36]	; (401c0c <vTaskPlaceOnEventList+0x54>)
  401be6:	4798      	blx	r3
  401be8:	bd38      	pop	{r3, r4, r5, pc}
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  401bea:	4b09      	ldr	r3, [pc, #36]	; (401c10 <vTaskPlaceOnEventList+0x58>)
  401bec:	6818      	ldr	r0, [r3, #0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
  401bee:	4420      	add	r0, r4
  401bf0:	4b08      	ldr	r3, [pc, #32]	; (401c14 <vTaskPlaceOnEventList+0x5c>)
  401bf2:	4798      	blx	r3
  401bf4:	bd38      	pop	{r3, r4, r5, pc}
  401bf6:	bf00      	nop
  401bf8:	00400da1 	.word	0x00400da1
  401bfc:	20002600 	.word	0x20002600
  401c00:	00400cdd 	.word	0x00400cdd
  401c04:	00400d19 	.word	0x00400d19
  401c08:	20002550 	.word	0x20002550
  401c0c:	00400cc1 	.word	0x00400cc1
  401c10:	2000261c 	.word	0x2000261c
  401c14:	00401549 	.word	0x00401549

00401c18 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
	{
  401c18:	b538      	push	{r3, r4, r5, lr}
	portTickType xTimeToWake;

		configASSERT( pxEventList );
  401c1a:	b918      	cbnz	r0, 401c24 <vTaskPlaceOnEventListRestricted+0xc>
  401c1c:	4b09      	ldr	r3, [pc, #36]	; (401c44 <vTaskPlaceOnEventListRestricted+0x2c>)
  401c1e:	4798      	blx	r3
  401c20:	bf00      	nop
  401c22:	e7fd      	b.n	401c20 <vTaskPlaceOnEventListRestricted+0x8>
  401c24:	460d      	mov	r5, r1

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  401c26:	4c08      	ldr	r4, [pc, #32]	; (401c48 <vTaskPlaceOnEventListRestricted+0x30>)
  401c28:	6821      	ldr	r1, [r4, #0]
  401c2a:	3118      	adds	r1, #24
  401c2c:	4b07      	ldr	r3, [pc, #28]	; (401c4c <vTaskPlaceOnEventListRestricted+0x34>)
  401c2e:	4798      	blx	r3

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
  401c30:	6820      	ldr	r0, [r4, #0]
  401c32:	3004      	adds	r0, #4
  401c34:	4b06      	ldr	r3, [pc, #24]	; (401c50 <vTaskPlaceOnEventListRestricted+0x38>)
  401c36:	4798      	blx	r3
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
  401c38:	4b06      	ldr	r3, [pc, #24]	; (401c54 <vTaskPlaceOnEventListRestricted+0x3c>)
  401c3a:	6818      	ldr	r0, [r3, #0]
		
		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
  401c3c:	4428      	add	r0, r5
  401c3e:	4b06      	ldr	r3, [pc, #24]	; (401c58 <vTaskPlaceOnEventListRestricted+0x40>)
  401c40:	4798      	blx	r3
  401c42:	bd38      	pop	{r3, r4, r5, pc}
  401c44:	00400da1 	.word	0x00400da1
  401c48:	20002600 	.word	0x20002600
  401c4c:	00400cc1 	.word	0x00400cc1
  401c50:	00400d19 	.word	0x00400d19
  401c54:	2000261c 	.word	0x2000261c
  401c58:	00401549 	.word	0x00401549

00401c5c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
  401c5c:	b538      	push	{r3, r4, r5, lr}
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  401c5e:	68c3      	ldr	r3, [r0, #12]
  401c60:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
  401c62:	b91c      	cbnz	r4, 401c6c <xTaskRemoveFromEventList+0x10>
  401c64:	4b16      	ldr	r3, [pc, #88]	; (401cc0 <xTaskRemoveFromEventList+0x64>)
  401c66:	4798      	blx	r3
  401c68:	bf00      	nop
  401c6a:	e7fd      	b.n	401c68 <xTaskRemoveFromEventList+0xc>
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  401c6c:	f104 0518 	add.w	r5, r4, #24
  401c70:	4628      	mov	r0, r5
  401c72:	4b14      	ldr	r3, [pc, #80]	; (401cc4 <xTaskRemoveFromEventList+0x68>)
  401c74:	4798      	blx	r3

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  401c76:	4b14      	ldr	r3, [pc, #80]	; (401cc8 <xTaskRemoveFromEventList+0x6c>)
  401c78:	681b      	ldr	r3, [r3, #0]
  401c7a:	b99b      	cbnz	r3, 401ca4 <xTaskRemoveFromEventList+0x48>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
  401c7c:	1d25      	adds	r5, r4, #4
  401c7e:	4628      	mov	r0, r5
  401c80:	4b10      	ldr	r3, [pc, #64]	; (401cc4 <xTaskRemoveFromEventList+0x68>)
  401c82:	4798      	blx	r3
		prvAddTaskToReadyQueue( pxUnblockedTCB );
  401c84:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  401c86:	4b11      	ldr	r3, [pc, #68]	; (401ccc <xTaskRemoveFromEventList+0x70>)
  401c88:	681b      	ldr	r3, [r3, #0]
  401c8a:	4298      	cmp	r0, r3
  401c8c:	bf84      	itt	hi
  401c8e:	4b0f      	ldrhi	r3, [pc, #60]	; (401ccc <xTaskRemoveFromEventList+0x70>)
  401c90:	6018      	strhi	r0, [r3, #0]
  401c92:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  401c96:	4629      	mov	r1, r5
  401c98:	4b0d      	ldr	r3, [pc, #52]	; (401cd0 <xTaskRemoveFromEventList+0x74>)
  401c9a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  401c9e:	4b0d      	ldr	r3, [pc, #52]	; (401cd4 <xTaskRemoveFromEventList+0x78>)
  401ca0:	4798      	blx	r3
  401ca2:	e003      	b.n	401cac <xTaskRemoveFromEventList+0x50>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  401ca4:	4629      	mov	r1, r5
  401ca6:	480c      	ldr	r0, [pc, #48]	; (401cd8 <xTaskRemoveFromEventList+0x7c>)
  401ca8:	4b0a      	ldr	r3, [pc, #40]	; (401cd4 <xTaskRemoveFromEventList+0x78>)
  401caa:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
  401cac:	4b0b      	ldr	r3, [pc, #44]	; (401cdc <xTaskRemoveFromEventList+0x80>)
  401cae:	681b      	ldr	r3, [r3, #0]
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
  401cb0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  401cb2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}
  401cb4:	4298      	cmp	r0, r3
  401cb6:	bf34      	ite	cc
  401cb8:	2000      	movcc	r0, #0
  401cba:	2001      	movcs	r0, #1
  401cbc:	bd38      	pop	{r3, r4, r5, pc}
  401cbe:	bf00      	nop
  401cc0:	00400da1 	.word	0x00400da1
  401cc4:	00400d19 	.word	0x00400d19
  401cc8:	200025fc 	.word	0x200025fc
  401ccc:	20002624 	.word	0x20002624
  401cd0:	20002598 	.word	0x20002598
  401cd4:	00400cc1 	.word	0x00400cc1
  401cd8:	20002604 	.word	0x20002604
  401cdc:	20002600 	.word	0x20002600

00401ce0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
  401ce0:	b508      	push	{r3, lr}
	configASSERT( pxTimeOut );
  401ce2:	b918      	cbnz	r0, 401cec <vTaskSetTimeOutState+0xc>
  401ce4:	4b05      	ldr	r3, [pc, #20]	; (401cfc <vTaskSetTimeOutState+0x1c>)
  401ce6:	4798      	blx	r3
  401ce8:	bf00      	nop
  401cea:	e7fd      	b.n	401ce8 <vTaskSetTimeOutState+0x8>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  401cec:	4a04      	ldr	r2, [pc, #16]	; (401d00 <vTaskSetTimeOutState+0x20>)
  401cee:	6812      	ldr	r2, [r2, #0]
  401cf0:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  401cf2:	4a04      	ldr	r2, [pc, #16]	; (401d04 <vTaskSetTimeOutState+0x24>)
  401cf4:	6812      	ldr	r2, [r2, #0]
  401cf6:	6042      	str	r2, [r0, #4]
  401cf8:	bd08      	pop	{r3, pc}
  401cfa:	bf00      	nop
  401cfc:	00400da1 	.word	0x00400da1
  401d00:	20002618 	.word	0x20002618
  401d04:	2000261c 	.word	0x2000261c

00401d08 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
  401d08:	b538      	push	{r3, r4, r5, lr}
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
  401d0a:	b918      	cbnz	r0, 401d14 <xTaskCheckForTimeOut+0xc>
  401d0c:	4b19      	ldr	r3, [pc, #100]	; (401d74 <xTaskCheckForTimeOut+0x6c>)
  401d0e:	4798      	blx	r3
  401d10:	bf00      	nop
  401d12:	e7fd      	b.n	401d10 <xTaskCheckForTimeOut+0x8>
  401d14:	460d      	mov	r5, r1
  401d16:	4604      	mov	r4, r0
	configASSERT( pxTicksToWait );
  401d18:	b919      	cbnz	r1, 401d22 <xTaskCheckForTimeOut+0x1a>
  401d1a:	4b16      	ldr	r3, [pc, #88]	; (401d74 <xTaskCheckForTimeOut+0x6c>)
  401d1c:	4798      	blx	r3
  401d1e:	bf00      	nop
  401d20:	e7fd      	b.n	401d1e <xTaskCheckForTimeOut+0x16>

	taskENTER_CRITICAL();
  401d22:	4b15      	ldr	r3, [pc, #84]	; (401d78 <xTaskCheckForTimeOut+0x70>)
  401d24:	4798      	blx	r3
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
  401d26:	682b      	ldr	r3, [r5, #0]
  401d28:	f1b3 3fff 	cmp.w	r3, #4294967295
  401d2c:	d018      	beq.n	401d60 <xTaskCheckForTimeOut+0x58>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
  401d2e:	4a13      	ldr	r2, [pc, #76]	; (401d7c <xTaskCheckForTimeOut+0x74>)
  401d30:	6812      	ldr	r2, [r2, #0]
  401d32:	6821      	ldr	r1, [r4, #0]
  401d34:	4291      	cmp	r1, r2
  401d36:	d004      	beq.n	401d42 <xTaskCheckForTimeOut+0x3a>
  401d38:	4a11      	ldr	r2, [pc, #68]	; (401d80 <xTaskCheckForTimeOut+0x78>)
  401d3a:	6812      	ldr	r2, [r2, #0]
  401d3c:	6861      	ldr	r1, [r4, #4]
  401d3e:	4291      	cmp	r1, r2
  401d40:	d910      	bls.n	401d64 <xTaskCheckForTimeOut+0x5c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
  401d42:	4a0f      	ldr	r2, [pc, #60]	; (401d80 <xTaskCheckForTimeOut+0x78>)
  401d44:	6811      	ldr	r1, [r2, #0]
  401d46:	6860      	ldr	r0, [r4, #4]
  401d48:	1a09      	subs	r1, r1, r0
  401d4a:	428b      	cmp	r3, r1
  401d4c:	d90c      	bls.n	401d68 <xTaskCheckForTimeOut+0x60>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
  401d4e:	6812      	ldr	r2, [r2, #0]
  401d50:	1a12      	subs	r2, r2, r0
  401d52:	1a9b      	subs	r3, r3, r2
  401d54:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
  401d56:	4620      	mov	r0, r4
  401d58:	4b0a      	ldr	r3, [pc, #40]	; (401d84 <xTaskCheckForTimeOut+0x7c>)
  401d5a:	4798      	blx	r3
			xReturn = pdFALSE;
  401d5c:	2400      	movs	r4, #0
  401d5e:	e004      	b.n	401d6a <xTaskCheckForTimeOut+0x62>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
  401d60:	2400      	movs	r4, #0
  401d62:	e002      	b.n	401d6a <xTaskCheckForTimeOut+0x62>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
  401d64:	2401      	movs	r4, #1
  401d66:	e000      	b.n	401d6a <xTaskCheckForTimeOut+0x62>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
  401d68:	2401      	movs	r4, #1
		}
	}
	taskEXIT_CRITICAL();
  401d6a:	4b07      	ldr	r3, [pc, #28]	; (401d88 <xTaskCheckForTimeOut+0x80>)
  401d6c:	4798      	blx	r3

	return xReturn;
}
  401d6e:	4620      	mov	r0, r4
  401d70:	bd38      	pop	{r3, r4, r5, pc}
  401d72:	bf00      	nop
  401d74:	00400da1 	.word	0x00400da1
  401d78:	00400db1 	.word	0x00400db1
  401d7c:	20002618 	.word	0x20002618
  401d80:	2000261c 	.word	0x2000261c
  401d84:	00401ce1 	.word	0x00401ce1
  401d88:	00400dd1 	.word	0x00400dd1

00401d8c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
  401d8c:	2201      	movs	r2, #1
  401d8e:	4b01      	ldr	r3, [pc, #4]	; (401d94 <vTaskMissedYield+0x8>)
  401d90:	601a      	str	r2, [r3, #0]
  401d92:	4770      	bx	lr
  401d94:	20002640 	.word	0x20002640

00401d98 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
  401d98:	4b01      	ldr	r3, [pc, #4]	; (401da0 <xTaskGetCurrentTaskHandle+0x8>)
  401d9a:	6818      	ldr	r0, [r3, #0]

		return xReturn;
	}
  401d9c:	4770      	bx	lr
  401d9e:	bf00      	nop
  401da0:	20002600 	.word	0x20002600

00401da4 <xTaskGetSchedulerState>:

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
  401da4:	4b05      	ldr	r3, [pc, #20]	; (401dbc <xTaskGetSchedulerState+0x18>)
  401da6:	681b      	ldr	r3, [r3, #0]
  401da8:	b133      	cbz	r3, 401db8 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  401daa:	4b05      	ldr	r3, [pc, #20]	; (401dc0 <xTaskGetSchedulerState+0x1c>)
  401dac:	681b      	ldr	r3, [r3, #0]
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
  401dae:	2b00      	cmp	r3, #0
  401db0:	bf0c      	ite	eq
  401db2:	2001      	moveq	r0, #1
  401db4:	2002      	movne	r0, #2
  401db6:	4770      	bx	lr
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
  401db8:	2000      	movs	r0, #0
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
  401dba:	4770      	bx	lr
  401dbc:	20002568 	.word	0x20002568
  401dc0:	200025fc 	.word	0x200025fc

00401dc4 <vTaskPriorityInherit>:
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
  401dc4:	2800      	cmp	r0, #0
  401dc6:	d031      	beq.n	401e2c <vTaskPriorityInherit+0x68>
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
  401dc8:	b538      	push	{r3, r4, r5, lr}

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  401dca:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  401dcc:	4918      	ldr	r1, [pc, #96]	; (401e30 <vTaskPriorityInherit+0x6c>)
  401dce:	6809      	ldr	r1, [r1, #0]
  401dd0:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  401dd2:	428b      	cmp	r3, r1
  401dd4:	d229      	bcs.n	401e2a <vTaskPriorityInherit+0x66>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  401dd6:	4916      	ldr	r1, [pc, #88]	; (401e30 <vTaskPriorityInherit+0x6c>)
  401dd8:	6809      	ldr	r1, [r1, #0]
  401dda:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  401ddc:	f1c1 0105 	rsb	r1, r1, #5
  401de0:	6181      	str	r1, [r0, #24]

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
  401de2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  401de6:	4913      	ldr	r1, [pc, #76]	; (401e34 <vTaskPriorityInherit+0x70>)
  401de8:	eb01 0383 	add.w	r3, r1, r3, lsl #2
  401dec:	6941      	ldr	r1, [r0, #20]
  401dee:	4299      	cmp	r1, r3
  401df0:	d117      	bne.n	401e22 <vTaskPriorityInherit+0x5e>
  401df2:	4605      	mov	r5, r0
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
  401df4:	1d04      	adds	r4, r0, #4
  401df6:	4620      	mov	r0, r4
  401df8:	4b0f      	ldr	r3, [pc, #60]	; (401e38 <vTaskPriorityInherit+0x74>)
  401dfa:	4798      	blx	r3
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  401dfc:	4b0c      	ldr	r3, [pc, #48]	; (401e30 <vTaskPriorityInherit+0x6c>)
  401dfe:	681b      	ldr	r3, [r3, #0]
  401e00:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  401e02:	62e8      	str	r0, [r5, #44]	; 0x2c
					prvAddTaskToReadyQueue( pxTCB );
  401e04:	4b0d      	ldr	r3, [pc, #52]	; (401e3c <vTaskPriorityInherit+0x78>)
  401e06:	681b      	ldr	r3, [r3, #0]
  401e08:	4298      	cmp	r0, r3
  401e0a:	bf84      	itt	hi
  401e0c:	4b0b      	ldrhi	r3, [pc, #44]	; (401e3c <vTaskPriorityInherit+0x78>)
  401e0e:	6018      	strhi	r0, [r3, #0]
  401e10:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  401e14:	4621      	mov	r1, r4
  401e16:	4b07      	ldr	r3, [pc, #28]	; (401e34 <vTaskPriorityInherit+0x70>)
  401e18:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  401e1c:	4b08      	ldr	r3, [pc, #32]	; (401e40 <vTaskPriorityInherit+0x7c>)
  401e1e:	4798      	blx	r3
  401e20:	bd38      	pop	{r3, r4, r5, pc}
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  401e22:	4b03      	ldr	r3, [pc, #12]	; (401e30 <vTaskPriorityInherit+0x6c>)
  401e24:	681b      	ldr	r3, [r3, #0]
  401e26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401e28:	62c3      	str	r3, [r0, #44]	; 0x2c
  401e2a:	bd38      	pop	{r3, r4, r5, pc}
  401e2c:	4770      	bx	lr
  401e2e:	bf00      	nop
  401e30:	20002600 	.word	0x20002600
  401e34:	20002598 	.word	0x20002598
  401e38:	00400d19 	.word	0x00400d19
  401e3c:	20002624 	.word	0x20002624
  401e40:	00400cc1 	.word	0x00400cc1

00401e44 <vTaskPriorityDisinherit>:

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
  401e44:	b1e8      	cbz	r0, 401e82 <vTaskPriorityDisinherit+0x3e>
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
  401e46:	b538      	push	{r3, r4, r5, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  401e48:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  401e4a:	6c02      	ldr	r2, [r0, #64]	; 0x40
  401e4c:	4291      	cmp	r1, r2
  401e4e:	d017      	beq.n	401e80 <vTaskPriorityDisinherit+0x3c>
  401e50:	4604      	mov	r4, r0
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
  401e52:	1d05      	adds	r5, r0, #4
  401e54:	4628      	mov	r0, r5
  401e56:	4b0b      	ldr	r3, [pc, #44]	; (401e84 <vTaskPriorityDisinherit+0x40>)
  401e58:	4798      	blx	r3
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  401e5a:	6c20      	ldr	r0, [r4, #64]	; 0x40
  401e5c:	62e0      	str	r0, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
  401e5e:	f1c0 0305 	rsb	r3, r0, #5
  401e62:	61a3      	str	r3, [r4, #24]
				prvAddTaskToReadyQueue( pxTCB );
  401e64:	4b08      	ldr	r3, [pc, #32]	; (401e88 <vTaskPriorityDisinherit+0x44>)
  401e66:	681b      	ldr	r3, [r3, #0]
  401e68:	4298      	cmp	r0, r3
  401e6a:	bf84      	itt	hi
  401e6c:	4b06      	ldrhi	r3, [pc, #24]	; (401e88 <vTaskPriorityDisinherit+0x44>)
  401e6e:	6018      	strhi	r0, [r3, #0]
  401e70:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  401e74:	4629      	mov	r1, r5
  401e76:	4b05      	ldr	r3, [pc, #20]	; (401e8c <vTaskPriorityDisinherit+0x48>)
  401e78:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  401e7c:	4b04      	ldr	r3, [pc, #16]	; (401e90 <vTaskPriorityDisinherit+0x4c>)
  401e7e:	4798      	blx	r3
  401e80:	bd38      	pop	{r3, r4, r5, pc}
  401e82:	4770      	bx	lr
  401e84:	00400d19 	.word	0x00400d19
  401e88:	20002624 	.word	0x20002624
  401e8c:	20002598 	.word	0x20002598
  401e90:	00400cc1 	.word	0x00400cc1

00401e94 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
  401e94:	b508      	push	{r3, lr}
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
  401e96:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  401e98:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
  401e9a:	4291      	cmp	r1, r2
  401e9c:	d80a      	bhi.n	401eb4 <prvInsertTimerInActiveList+0x20>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
  401e9e:	1ad2      	subs	r2, r2, r3
  401ea0:	6983      	ldr	r3, [r0, #24]
  401ea2:	429a      	cmp	r2, r3
  401ea4:	d211      	bcs.n	401eca <prvInsertTimerInActiveList+0x36>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
  401ea6:	1d01      	adds	r1, r0, #4
  401ea8:	4b0a      	ldr	r3, [pc, #40]	; (401ed4 <prvInsertTimerInActiveList+0x40>)
  401eaa:	6818      	ldr	r0, [r3, #0]
  401eac:	4b0a      	ldr	r3, [pc, #40]	; (401ed8 <prvInsertTimerInActiveList+0x44>)
  401eae:	4798      	blx	r3
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
portBASE_TYPE xProcessTimerNow = pdFALSE;
  401eb0:	2000      	movs	r0, #0
  401eb2:	bd08      	pop	{r3, pc}
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
  401eb4:	429a      	cmp	r2, r3
  401eb6:	d201      	bcs.n	401ebc <prvInsertTimerInActiveList+0x28>
  401eb8:	4299      	cmp	r1, r3
  401eba:	d208      	bcs.n	401ece <prvInsertTimerInActiveList+0x3a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  401ebc:	1d01      	adds	r1, r0, #4
  401ebe:	4b07      	ldr	r3, [pc, #28]	; (401edc <prvInsertTimerInActiveList+0x48>)
  401ec0:	6818      	ldr	r0, [r3, #0]
  401ec2:	4b05      	ldr	r3, [pc, #20]	; (401ed8 <prvInsertTimerInActiveList+0x44>)
  401ec4:	4798      	blx	r3
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
portBASE_TYPE xProcessTimerNow = pdFALSE;
  401ec6:	2000      	movs	r0, #0
  401ec8:	bd08      	pop	{r3, pc}
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
  401eca:	2001      	movs	r0, #1
  401ecc:	bd08      	pop	{r3, pc}
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
  401ece:	2001      	movs	r0, #1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
  401ed0:	bd08      	pop	{r3, pc}
  401ed2:	bf00      	nop
  401ed4:	20002680 	.word	0x20002680
  401ed8:	00400cdd 	.word	0x00400cdd
  401edc:	2000264c 	.word	0x2000264c

00401ee0 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
  401ee0:	b570      	push	{r4, r5, r6, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
  401ee2:	4b0d      	ldr	r3, [pc, #52]	; (401f18 <prvCheckForValidListAndQueue+0x38>)
  401ee4:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
  401ee6:	4b0d      	ldr	r3, [pc, #52]	; (401f1c <prvCheckForValidListAndQueue+0x3c>)
  401ee8:	681b      	ldr	r3, [r3, #0]
  401eea:	b98b      	cbnz	r3, 401f10 <prvCheckForValidListAndQueue+0x30>
		{
			vListInitialise( &xActiveTimerList1 );
  401eec:	4d0c      	ldr	r5, [pc, #48]	; (401f20 <prvCheckForValidListAndQueue+0x40>)
  401eee:	4628      	mov	r0, r5
  401ef0:	4e0c      	ldr	r6, [pc, #48]	; (401f24 <prvCheckForValidListAndQueue+0x44>)
  401ef2:	47b0      	blx	r6
			vListInitialise( &xActiveTimerList2 );
  401ef4:	4c0c      	ldr	r4, [pc, #48]	; (401f28 <prvCheckForValidListAndQueue+0x48>)
  401ef6:	4620      	mov	r0, r4
  401ef8:	47b0      	blx	r6
			pxCurrentTimerList = &xActiveTimerList1;
  401efa:	4b0c      	ldr	r3, [pc, #48]	; (401f2c <prvCheckForValidListAndQueue+0x4c>)
  401efc:	601d      	str	r5, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
  401efe:	4b0c      	ldr	r3, [pc, #48]	; (401f30 <prvCheckForValidListAndQueue+0x50>)
  401f00:	601c      	str	r4, [r3, #0]
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
  401f02:	2200      	movs	r2, #0
  401f04:	210c      	movs	r1, #12
  401f06:	2005      	movs	r0, #5
  401f08:	4b0a      	ldr	r3, [pc, #40]	; (401f34 <prvCheckForValidListAndQueue+0x54>)
  401f0a:	4798      	blx	r3
  401f0c:	4b03      	ldr	r3, [pc, #12]	; (401f1c <prvCheckForValidListAndQueue+0x3c>)
  401f0e:	6018      	str	r0, [r3, #0]
		}
	}
	taskEXIT_CRITICAL();
  401f10:	4b09      	ldr	r3, [pc, #36]	; (401f38 <prvCheckForValidListAndQueue+0x58>)
  401f12:	4798      	blx	r3
  401f14:	bd70      	pop	{r4, r5, r6, pc}
  401f16:	bf00      	nop
  401f18:	00400db1 	.word	0x00400db1
  401f1c:	2000267c 	.word	0x2000267c
  401f20:	20002650 	.word	0x20002650
  401f24:	00400ca1 	.word	0x00400ca1
  401f28:	20002664 	.word	0x20002664
  401f2c:	2000264c 	.word	0x2000264c
  401f30:	20002680 	.word	0x20002680
  401f34:	0040119d 	.word	0x0040119d
  401f38:	00400dd1 	.word	0x00400dd1

00401f3c <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
  401f3c:	b510      	push	{r4, lr}
  401f3e:	b084      	sub	sp, #16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
  401f40:	4b0b      	ldr	r3, [pc, #44]	; (401f70 <xTimerCreateTimerTask+0x34>)
  401f42:	4798      	blx	r3

	if( xTimerQueue != NULL )
  401f44:	4b0b      	ldr	r3, [pc, #44]	; (401f74 <xTimerCreateTimerTask+0x38>)
  401f46:	681b      	ldr	r3, [r3, #0]
  401f48:	b15b      	cbz	r3, 401f62 <xTimerCreateTimerTask+0x26>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
  401f4a:	2300      	movs	r3, #0
  401f4c:	9303      	str	r3, [sp, #12]
  401f4e:	9302      	str	r3, [sp, #8]
  401f50:	9301      	str	r3, [sp, #4]
  401f52:	2204      	movs	r2, #4
  401f54:	9200      	str	r2, [sp, #0]
  401f56:	22c8      	movs	r2, #200	; 0xc8
  401f58:	4907      	ldr	r1, [pc, #28]	; (401f78 <xTimerCreateTimerTask+0x3c>)
  401f5a:	4808      	ldr	r0, [pc, #32]	; (401f7c <xTimerCreateTimerTask+0x40>)
  401f5c:	4c08      	ldr	r4, [pc, #32]	; (401f80 <xTimerCreateTimerTask+0x44>)
  401f5e:	47a0      	blx	r4
		}
		#endif
	}

	configASSERT( xReturn );
  401f60:	b918      	cbnz	r0, 401f6a <xTimerCreateTimerTask+0x2e>
  401f62:	4b08      	ldr	r3, [pc, #32]	; (401f84 <xTimerCreateTimerTask+0x48>)
  401f64:	4798      	blx	r3
  401f66:	bf00      	nop
  401f68:	e7fd      	b.n	401f66 <xTimerCreateTimerTask+0x2a>
	return xReturn;
}
  401f6a:	b004      	add	sp, #16
  401f6c:	bd10      	pop	{r4, pc}
  401f6e:	bf00      	nop
  401f70:	00401ee1 	.word	0x00401ee1
  401f74:	2000267c 	.word	0x2000267c
  401f78:	00402648 	.word	0x00402648
  401f7c:	00402091 	.word	0x00402091
  401f80:	004015a1 	.word	0x004015a1
  401f84:	00400da1 	.word	0x00400da1

00401f88 <xTimerGenericCommand>:
	return ( xTimerHandle ) pxNewTimer;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
  401f88:	b530      	push	{r4, r5, lr}
  401f8a:	b085      	sub	sp, #20
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
  401f8c:	4c0f      	ldr	r4, [pc, #60]	; (401fcc <xTimerGenericCommand+0x44>)
  401f8e:	6825      	ldr	r5, [r4, #0]
  401f90:	b1cd      	cbz	r5, 401fc6 <xTimerGenericCommand+0x3e>
  401f92:	461c      	mov	r4, r3
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
  401f94:	9101      	str	r1, [sp, #4]
		xMessage.xMessageValue = xOptionalValue;
  401f96:	9202      	str	r2, [sp, #8]
		xMessage.pxTimer = ( xTIMER * ) xTimer;
  401f98:	9003      	str	r0, [sp, #12]

		if( pxHigherPriorityTaskWoken == NULL )
  401f9a:	b96c      	cbnz	r4, 401fb8 <xTimerGenericCommand+0x30>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
  401f9c:	4b0c      	ldr	r3, [pc, #48]	; (401fd0 <xTimerGenericCommand+0x48>)
  401f9e:	4798      	blx	r3
  401fa0:	2801      	cmp	r0, #1
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
  401fa2:	f04f 0300 	mov.w	r3, #0
  401fa6:	bf0c      	ite	eq
  401fa8:	9a08      	ldreq	r2, [sp, #32]
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  401faa:	461a      	movne	r2, r3
  401fac:	a901      	add	r1, sp, #4
  401fae:	4807      	ldr	r0, [pc, #28]	; (401fcc <xTimerGenericCommand+0x44>)
  401fb0:	6800      	ldr	r0, [r0, #0]
  401fb2:	4c08      	ldr	r4, [pc, #32]	; (401fd4 <xTimerGenericCommand+0x4c>)
  401fb4:	47a0      	blx	r4
  401fb6:	e007      	b.n	401fc8 <xTimerGenericCommand+0x40>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
  401fb8:	2300      	movs	r3, #0
  401fba:	4622      	mov	r2, r4
  401fbc:	a901      	add	r1, sp, #4
  401fbe:	4628      	mov	r0, r5
  401fc0:	4c05      	ldr	r4, [pc, #20]	; (401fd8 <xTimerGenericCommand+0x50>)
  401fc2:	47a0      	blx	r4
  401fc4:	e000      	b.n	401fc8 <xTimerGenericCommand+0x40>
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
portBASE_TYPE xReturn = pdFAIL;
  401fc6:	2000      	movs	r0, #0

		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}

	return xReturn;
}
  401fc8:	b005      	add	sp, #20
  401fca:	bd30      	pop	{r4, r5, pc}
  401fcc:	2000267c 	.word	0x2000267c
  401fd0:	00401da5 	.word	0x00401da5
  401fd4:	004011f1 	.word	0x004011f1
  401fd8:	00401311 	.word	0x00401311

00401fdc <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
  401fdc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  401fe0:	b082      	sub	sp, #8
  401fe2:	4681      	mov	r9, r0
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
  401fe4:	4b22      	ldr	r3, [pc, #136]	; (402070 <prvSampleTimeNow+0x94>)
  401fe6:	4798      	blx	r3
  401fe8:	4680      	mov	r8, r0

	if( xTimeNow < xLastTime )
  401fea:	4b22      	ldr	r3, [pc, #136]	; (402074 <prvSampleTimeNow+0x98>)
  401fec:	681b      	ldr	r3, [r3, #0]
  401fee:	4298      	cmp	r0, r3
  401ff0:	d234      	bcs.n	40205c <prvSampleTimeNow+0x80>
  401ff2:	e024      	b.n	40203e <prvSampleTimeNow+0x62>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  401ff4:	68da      	ldr	r2, [r3, #12]
  401ff6:	f8d2 a000 	ldr.w	sl, [r2]

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  401ffa:	68db      	ldr	r3, [r3, #12]
  401ffc:	68dc      	ldr	r4, [r3, #12]
		uxListRemove( &( pxTimer->xTimerListItem ) );
  401ffe:	1d25      	adds	r5, r4, #4
  402000:	4628      	mov	r0, r5
  402002:	47b8      	blx	r7

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  402004:	6a63      	ldr	r3, [r4, #36]	; 0x24
  402006:	4620      	mov	r0, r4
  402008:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  40200a:	69e3      	ldr	r3, [r4, #28]
  40200c:	2b01      	cmp	r3, #1
  40200e:	d118      	bne.n	402042 <prvSampleTimeNow+0x66>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
  402010:	69a3      	ldr	r3, [r4, #24]
  402012:	4453      	add	r3, sl
			if( xReloadTime > xNextExpireTime )
  402014:	459a      	cmp	sl, r3
  402016:	d206      	bcs.n	402026 <prvSampleTimeNow+0x4a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
  402018:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  40201a:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  40201c:	4629      	mov	r1, r5
  40201e:	6830      	ldr	r0, [r6, #0]
  402020:	4b15      	ldr	r3, [pc, #84]	; (402078 <prvSampleTimeNow+0x9c>)
  402022:	4798      	blx	r3
  402024:	e00d      	b.n	402042 <prvSampleTimeNow+0x66>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  402026:	2100      	movs	r1, #0
  402028:	9100      	str	r1, [sp, #0]
  40202a:	460b      	mov	r3, r1
  40202c:	4652      	mov	r2, sl
  40202e:	4620      	mov	r0, r4
  402030:	4c12      	ldr	r4, [pc, #72]	; (40207c <prvSampleTimeNow+0xa0>)
  402032:	47a0      	blx	r4
				configASSERT( xResult );
  402034:	b928      	cbnz	r0, 402042 <prvSampleTimeNow+0x66>
  402036:	4b12      	ldr	r3, [pc, #72]	; (402080 <prvSampleTimeNow+0xa4>)
  402038:	4798      	blx	r3
  40203a:	bf00      	nop
  40203c:	e7fd      	b.n	40203a <prvSampleTimeNow+0x5e>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  40203e:	4e11      	ldr	r6, [pc, #68]	; (402084 <prvSampleTimeNow+0xa8>)
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
		uxListRemove( &( pxTimer->xTimerListItem ) );
  402040:	4f11      	ldr	r7, [pc, #68]	; (402088 <prvSampleTimeNow+0xac>)

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  402042:	6833      	ldr	r3, [r6, #0]
  402044:	681a      	ldr	r2, [r3, #0]
  402046:	2a00      	cmp	r2, #0
  402048:	d1d4      	bne.n	401ff4 <prvSampleTimeNow+0x18>
			}
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
  40204a:	4a10      	ldr	r2, [pc, #64]	; (40208c <prvSampleTimeNow+0xb0>)
  40204c:	6810      	ldr	r0, [r2, #0]
  40204e:	490d      	ldr	r1, [pc, #52]	; (402084 <prvSampleTimeNow+0xa8>)
  402050:	6008      	str	r0, [r1, #0]
	pxOverflowTimerList = pxTemp;
  402052:	6013      	str	r3, [r2, #0]
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists( xLastTime );
		*pxTimerListsWereSwitched = pdTRUE;
  402054:	2301      	movs	r3, #1
  402056:	f8c9 3000 	str.w	r3, [r9]
  40205a:	e002      	b.n	402062 <prvSampleTimeNow+0x86>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
  40205c:	2300      	movs	r3, #0
  40205e:	f8c9 3000 	str.w	r3, [r9]
	}

	xLastTime = xTimeNow;
  402062:	4b04      	ldr	r3, [pc, #16]	; (402074 <prvSampleTimeNow+0x98>)
  402064:	f8c3 8000 	str.w	r8, [r3]

	return xTimeNow;
}
  402068:	4640      	mov	r0, r8
  40206a:	b002      	add	sp, #8
  40206c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  402070:	00401819 	.word	0x00401819
  402074:	20002678 	.word	0x20002678
  402078:	00400cdd 	.word	0x00400cdd
  40207c:	00401f89 	.word	0x00401f89
  402080:	00400da1 	.word	0x00400da1
  402084:	2000264c 	.word	0x2000264c
  402088:	00400d19 	.word	0x00400d19
  40208c:	20002680 	.word	0x20002680

00402090 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
  402090:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  402094:	b087      	sub	sp, #28
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
  402096:	4d4d      	ldr	r5, [pc, #308]	; (4021cc <prvTimerTask+0x13c>)
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
	uxListRemove( &( pxTimer->xTimerListItem ) );
  402098:	f8df 8160 	ldr.w	r8, [pc, #352]	; 4021fc <prvTimerTask+0x16c>
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  40209c:	4b4c      	ldr	r3, [pc, #304]	; (4021d0 <prvTimerTask+0x140>)
  40209e:	681b      	ldr	r3, [r3, #0]
  4020a0:	681a      	ldr	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
  4020a2:	2a00      	cmp	r2, #0
  4020a4:	f000 8088 	beq.w	4021b8 <prvTimerTask+0x128>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  4020a8:	68db      	ldr	r3, [r3, #12]
  4020aa:	681e      	ldr	r6, [r3, #0]
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
  4020ac:	4b49      	ldr	r3, [pc, #292]	; (4021d4 <prvTimerTask+0x144>)
  4020ae:	4798      	blx	r3
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  4020b0:	a803      	add	r0, sp, #12
  4020b2:	4b49      	ldr	r3, [pc, #292]	; (4021d8 <prvTimerTask+0x148>)
  4020b4:	4798      	blx	r3
  4020b6:	4607      	mov	r7, r0
		if( xTimerListsWereSwitched == pdFALSE )
  4020b8:	9b03      	ldr	r3, [sp, #12]
  4020ba:	2b00      	cmp	r3, #0
  4020bc:	d130      	bne.n	402120 <prvTimerTask+0x90>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
  4020be:	4286      	cmp	r6, r0
  4020c0:	d824      	bhi.n	40210c <prvTimerTask+0x7c>
			{
				xTaskResumeAll();
  4020c2:	4b46      	ldr	r3, [pc, #280]	; (4021dc <prvTimerTask+0x14c>)
  4020c4:	4798      	blx	r3
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  4020c6:	4b42      	ldr	r3, [pc, #264]	; (4021d0 <prvTimerTask+0x140>)
  4020c8:	681b      	ldr	r3, [r3, #0]
  4020ca:	68db      	ldr	r3, [r3, #12]
  4020cc:	68dc      	ldr	r4, [r3, #12]
	uxListRemove( &( pxTimer->xTimerListItem ) );
  4020ce:	1d20      	adds	r0, r4, #4
  4020d0:	47c0      	blx	r8
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  4020d2:	69e3      	ldr	r3, [r4, #28]
  4020d4:	2b01      	cmp	r3, #1
  4020d6:	d114      	bne.n	402102 <prvTimerTask+0x72>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
  4020d8:	69a1      	ldr	r1, [r4, #24]
  4020da:	4633      	mov	r3, r6
  4020dc:	463a      	mov	r2, r7
  4020de:	4431      	add	r1, r6
  4020e0:	4620      	mov	r0, r4
  4020e2:	4f3f      	ldr	r7, [pc, #252]	; (4021e0 <prvTimerTask+0x150>)
  4020e4:	47b8      	blx	r7
  4020e6:	2801      	cmp	r0, #1
  4020e8:	d10b      	bne.n	402102 <prvTimerTask+0x72>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  4020ea:	2100      	movs	r1, #0
  4020ec:	9100      	str	r1, [sp, #0]
  4020ee:	460b      	mov	r3, r1
  4020f0:	4632      	mov	r2, r6
  4020f2:	4620      	mov	r0, r4
  4020f4:	4e3b      	ldr	r6, [pc, #236]	; (4021e4 <prvTimerTask+0x154>)
  4020f6:	47b0      	blx	r6
			configASSERT( xResult );
  4020f8:	b918      	cbnz	r0, 402102 <prvTimerTask+0x72>
  4020fa:	4b3b      	ldr	r3, [pc, #236]	; (4021e8 <prvTimerTask+0x158>)
  4020fc:	4798      	blx	r3
  4020fe:	bf00      	nop
  402100:	e7fd      	b.n	4020fe <prvTimerTask+0x6e>
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  402102:	6a63      	ldr	r3, [r4, #36]	; 0x24
  402104:	4620      	mov	r0, r4
  402106:	4798      	blx	r3
  402108:	e00c      	b.n	402124 <prvTimerTask+0x94>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
  40210a:	2600      	movs	r6, #0
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
  40210c:	1bf1      	subs	r1, r6, r7
  40210e:	6828      	ldr	r0, [r5, #0]
  402110:	4b36      	ldr	r3, [pc, #216]	; (4021ec <prvTimerTask+0x15c>)
  402112:	4798      	blx	r3

				if( xTaskResumeAll() == pdFALSE )
  402114:	4b31      	ldr	r3, [pc, #196]	; (4021dc <prvTimerTask+0x14c>)
  402116:	4798      	blx	r3
  402118:	b920      	cbnz	r0, 402124 <prvTimerTask+0x94>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
  40211a:	4b35      	ldr	r3, [pc, #212]	; (4021f0 <prvTimerTask+0x160>)
  40211c:	4798      	blx	r3
  40211e:	e001      	b.n	402124 <prvTimerTask+0x94>
				}
			}
		}
		else
		{
			xTaskResumeAll();
  402120:	4b2e      	ldr	r3, [pc, #184]	; (4021dc <prvTimerTask+0x14c>)
  402122:	4798      	blx	r3
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  402124:	a802      	add	r0, sp, #8
  402126:	4b2c      	ldr	r3, [pc, #176]	; (4021d8 <prvTimerTask+0x148>)
  402128:	4798      	blx	r3
  40212a:	4607      	mov	r7, r0

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
  40212c:	4e31      	ldr	r6, [pc, #196]	; (4021f4 <prvTimerTask+0x164>)
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
  40212e:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 4021e0 <prvTimerTask+0x150>
  402132:	e039      	b.n	4021a8 <prvTimerTask+0x118>
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
	{
		pxTimer = xMessage.pxTimer;
  402134:	9c05      	ldr	r4, [sp, #20]

		/* Is the timer already in a list of active timers?  When the command
		is trmCOMMAND_PROCESS_TIMER_OVERFLOW, the timer will be NULL as the
		command is to the task rather than to an individual timer. */
		if( pxTimer != NULL )
  402136:	b11c      	cbz	r4, 402140 <prvTimerTask+0xb0>
		{
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
  402138:	6963      	ldr	r3, [r4, #20]
  40213a:	b10b      	cbz	r3, 402140 <prvTimerTask+0xb0>
			{
				/* The timer is in a list, remove it. */
				uxListRemove( &( pxTimer->xTimerListItem ) );
  40213c:	1d20      	adds	r0, r4, #4
  40213e:	47c0      	blx	r8
			}
		}

		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );

		switch( xMessage.xMessageID )
  402140:	9b03      	ldr	r3, [sp, #12]
  402142:	2b02      	cmp	r3, #2
  402144:	d020      	beq.n	402188 <prvTimerTask+0xf8>
  402146:	2b03      	cmp	r3, #3
  402148:	d02b      	beq.n	4021a2 <prvTimerTask+0x112>
  40214a:	2b00      	cmp	r3, #0
  40214c:	d12c      	bne.n	4021a8 <prvTimerTask+0x118>
		{
			case tmrCOMMAND_START :
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
  40214e:	9904      	ldr	r1, [sp, #16]
  402150:	69a0      	ldr	r0, [r4, #24]
  402152:	460b      	mov	r3, r1
  402154:	463a      	mov	r2, r7
  402156:	4401      	add	r1, r0
  402158:	4620      	mov	r0, r4
  40215a:	47c8      	blx	r9
  40215c:	2801      	cmp	r0, #1
  40215e:	d123      	bne.n	4021a8 <prvTimerTask+0x118>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  402160:	6a63      	ldr	r3, [r4, #36]	; 0x24
  402162:	4620      	mov	r0, r4
  402164:	4798      	blx	r3

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  402166:	69e3      	ldr	r3, [r4, #28]
  402168:	2b01      	cmp	r3, #1
  40216a:	d11d      	bne.n	4021a8 <prvTimerTask+0x118>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
  40216c:	69a2      	ldr	r2, [r4, #24]
  40216e:	2100      	movs	r1, #0
  402170:	9100      	str	r1, [sp, #0]
  402172:	460b      	mov	r3, r1
  402174:	9804      	ldr	r0, [sp, #16]
  402176:	4402      	add	r2, r0
  402178:	4620      	mov	r0, r4
  40217a:	4c1a      	ldr	r4, [pc, #104]	; (4021e4 <prvTimerTask+0x154>)
  40217c:	47a0      	blx	r4
						configASSERT( xResult );
  40217e:	b998      	cbnz	r0, 4021a8 <prvTimerTask+0x118>
  402180:	4b19      	ldr	r3, [pc, #100]	; (4021e8 <prvTimerTask+0x158>)
  402182:	4798      	blx	r3
  402184:	bf00      	nop
  402186:	e7fd      	b.n	402184 <prvTimerTask+0xf4>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
  402188:	9904      	ldr	r1, [sp, #16]
  40218a:	61a1      	str	r1, [r4, #24]
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
  40218c:	b919      	cbnz	r1, 402196 <prvTimerTask+0x106>
  40218e:	4b16      	ldr	r3, [pc, #88]	; (4021e8 <prvTimerTask+0x158>)
  402190:	4798      	blx	r3
  402192:	bf00      	nop
  402194:	e7fd      	b.n	402192 <prvTimerTask+0x102>
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
  402196:	463b      	mov	r3, r7
  402198:	463a      	mov	r2, r7
  40219a:	4439      	add	r1, r7
  40219c:	4620      	mov	r0, r4
  40219e:	47c8      	blx	r9
  4021a0:	e002      	b.n	4021a8 <prvTimerTask+0x118>
				break;

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
  4021a2:	4620      	mov	r0, r4
  4021a4:	4b14      	ldr	r3, [pc, #80]	; (4021f8 <prvTimerTask+0x168>)
  4021a6:	4798      	blx	r3

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
  4021a8:	2300      	movs	r3, #0
  4021aa:	461a      	mov	r2, r3
  4021ac:	a903      	add	r1, sp, #12
  4021ae:	6828      	ldr	r0, [r5, #0]
  4021b0:	47b0      	blx	r6
  4021b2:	2800      	cmp	r0, #0
  4021b4:	d1be      	bne.n	402134 <prvTimerTask+0xa4>
  4021b6:	e771      	b.n	40209c <prvTimerTask+0xc>
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
  4021b8:	4b06      	ldr	r3, [pc, #24]	; (4021d4 <prvTimerTask+0x144>)
  4021ba:	4798      	blx	r3
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  4021bc:	a803      	add	r0, sp, #12
  4021be:	4b06      	ldr	r3, [pc, #24]	; (4021d8 <prvTimerTask+0x148>)
  4021c0:	4798      	blx	r3
  4021c2:	4607      	mov	r7, r0
		if( xTimerListsWereSwitched == pdFALSE )
  4021c4:	9b03      	ldr	r3, [sp, #12]
  4021c6:	2b00      	cmp	r3, #0
  4021c8:	d09f      	beq.n	40210a <prvTimerTask+0x7a>
  4021ca:	e7a9      	b.n	402120 <prvTimerTask+0x90>
  4021cc:	2000267c 	.word	0x2000267c
  4021d0:	2000264c 	.word	0x2000264c
  4021d4:	00401809 	.word	0x00401809
  4021d8:	00401fdd 	.word	0x00401fdd
  4021dc:	00401959 	.word	0x00401959
  4021e0:	00401e95 	.word	0x00401e95
  4021e4:	00401f89 	.word	0x00401f89
  4021e8:	00400da1 	.word	0x00400da1
  4021ec:	004014fd 	.word	0x004014fd
  4021f0:	00400d91 	.word	0x00400d91
  4021f4:	004013a1 	.word	0x004013a1
  4021f8:	00400fcd 	.word	0x00400fcd
  4021fc:	00400d19 	.word	0x00400d19

00402200 <vBlinkTask>:
	gpio_configure_pin(PIO_PC23_IDX, (PIO_OUTPUT_1 | PIO_DEFAULT));

}

void vBlinkTask( void *pvParameters )
{
  402200:	b580      	push	{r7, lr}
	while(1)
	{
		//LED1_Write(1);
		gpio_set_pin_high(PIO_PC23_IDX);
  402202:	2657      	movs	r6, #87	; 0x57
  402204:	4f06      	ldr	r7, [pc, #24]	; (402220 <vBlinkTask+0x20>)
		//UART0_PutChar('A');
		vTaskDelay(500);
  402206:	f44f 75fa 	mov.w	r5, #500	; 0x1f4
void vBlinkTask( void *pvParameters )
{
	while(1)
	{
		//LED1_Write(1);
		gpio_set_pin_high(PIO_PC23_IDX);
  40220a:	4630      	mov	r0, r6
  40220c:	47b8      	blx	r7
		//UART0_PutChar('A');
		vTaskDelay(500);
  40220e:	4628      	mov	r0, r5
  402210:	4c04      	ldr	r4, [pc, #16]	; (402224 <vBlinkTask+0x24>)
  402212:	47a0      	blx	r4
		//LED1_Write(0);
		gpio_set_pin_low(PIO_PC23_IDX);
  402214:	4630      	mov	r0, r6
  402216:	4b04      	ldr	r3, [pc, #16]	; (402228 <vBlinkTask+0x28>)
  402218:	4798      	blx	r3
		//Debug_PutChar('A');
		vTaskDelay(500);
  40221a:	4628      	mov	r0, r5
  40221c:	47a0      	blx	r4
  40221e:	e7f4      	b.n	40220a <vBlinkTask+0xa>
  402220:	00400761 	.word	0x00400761
  402224:	00401a5d 	.word	0x00401a5d
  402228:	0040077d 	.word	0x0040077d

0040222c <vApplicationMallocFailedHook>:
// 	taskDISABLE_INTERRUPTS();
// 	for( ;; );
// }
// 
void vApplicationMallocFailedHook( void )
{
  40222c:	b508      	push	{r3, lr}
	/* The heap space has been execeeded. */
	taskDISABLE_INTERRUPTS();
  40222e:	4b01      	ldr	r3, [pc, #4]	; (402234 <vApplicationMallocFailedHook+0x8>)
  402230:	4798      	blx	r3
  402232:	e7fe      	b.n	402232 <vApplicationMallocFailedHook+0x6>
  402234:	00400da1 	.word	0x00400da1

00402238 <vInitPeripherals>:
	for( ;; );
}

void vInitPeripherals( void )
{
  402238:	b508      	push	{r3, lr}
	/* Initialize all RTOS vars */
// 	vCCInit();
// 	vPvTrackerInit();
// 	vCommInit();

	gpio_configure_pin(PIO_PC23_IDX, (PIO_OUTPUT_1 | PIO_DEFAULT));
  40223a:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  40223e:	2057      	movs	r0, #87	; 0x57
  402240:	4b01      	ldr	r3, [pc, #4]	; (402248 <vInitPeripherals+0x10>)
  402242:	4798      	blx	r3
  402244:	bd08      	pop	{r3, pc}
  402246:	bf00      	nop
  402248:	00400799 	.word	0x00400799

0040224c <main>:

/* RTOS Task Declarations*/
void vBlinkTask(void *pvParameters);

int main (void)
{
  40224c:	b500      	push	{lr}
  40224e:	b085      	sub	sp, #20
	/* Insert system clock initialization code here (sysclk_init()). */
	sysclk_init();
  402250:	4b08      	ldr	r3, [pc, #32]	; (402274 <main+0x28>)
  402252:	4798      	blx	r3
	/* There is nothing in board_init() as it is a custom board, hence we call this*/
	vInitPeripherals();
  402254:	4b08      	ldr	r3, [pc, #32]	; (402278 <main+0x2c>)
  402256:	4798      	blx	r3
    /* Enable global interrupts. */   
    
//     xTaskCreate(vCCTask, "Cc", 100, NULL, 2, NULL);
//     xTaskCreate(vPvTrackerTask, "Pv", 300, NULL, 1, NULL);
//     xTaskCreate(vCommTask, "Comm", 512, NULL, 1, NULL);
	   xTaskCreate(vBlinkTask, "Blinky", 100, NULL, 1, NULL);
  402258:	2300      	movs	r3, #0
  40225a:	9303      	str	r3, [sp, #12]
  40225c:	9302      	str	r3, [sp, #8]
  40225e:	9301      	str	r3, [sp, #4]
  402260:	2201      	movs	r2, #1
  402262:	9200      	str	r2, [sp, #0]
  402264:	2264      	movs	r2, #100	; 0x64
  402266:	4905      	ldr	r1, [pc, #20]	; (40227c <main+0x30>)
  402268:	4805      	ldr	r0, [pc, #20]	; (402280 <main+0x34>)
  40226a:	4c06      	ldr	r4, [pc, #24]	; (402284 <main+0x38>)
  40226c:	47a0      	blx	r4
    PWM0_Start();
    PWM0_WriteCompare(1023);
    PwmSelReg_Write(0);
    while(1);*/
    
    vTaskStartScheduler();
  40226e:	4b06      	ldr	r3, [pc, #24]	; (402288 <main+0x3c>)
  402270:	4798      	blx	r3
  402272:	e7fe      	b.n	402272 <main+0x26>
  402274:	00400609 	.word	0x00400609
  402278:	00402239 	.word	0x00402239
  40227c:	00402650 	.word	0x00402650
  402280:	00402201 	.word	0x00402201
  402284:	004015a1 	.word	0x004015a1
  402288:	004017a1 	.word	0x004017a1

0040228c <__libc_init_array>:
  40228c:	b570      	push	{r4, r5, r6, lr}
  40228e:	4e0f      	ldr	r6, [pc, #60]	; (4022cc <__libc_init_array+0x40>)
  402290:	4d0f      	ldr	r5, [pc, #60]	; (4022d0 <__libc_init_array+0x44>)
  402292:	1b76      	subs	r6, r6, r5
  402294:	10b6      	asrs	r6, r6, #2
  402296:	bf18      	it	ne
  402298:	2400      	movne	r4, #0
  40229a:	d005      	beq.n	4022a8 <__libc_init_array+0x1c>
  40229c:	3401      	adds	r4, #1
  40229e:	f855 3b04 	ldr.w	r3, [r5], #4
  4022a2:	4798      	blx	r3
  4022a4:	42a6      	cmp	r6, r4
  4022a6:	d1f9      	bne.n	40229c <__libc_init_array+0x10>
  4022a8:	4e0a      	ldr	r6, [pc, #40]	; (4022d4 <__libc_init_array+0x48>)
  4022aa:	4d0b      	ldr	r5, [pc, #44]	; (4022d8 <__libc_init_array+0x4c>)
  4022ac:	1b76      	subs	r6, r6, r5
  4022ae:	f000 f9d7 	bl	402660 <_init>
  4022b2:	10b6      	asrs	r6, r6, #2
  4022b4:	bf18      	it	ne
  4022b6:	2400      	movne	r4, #0
  4022b8:	d006      	beq.n	4022c8 <__libc_init_array+0x3c>
  4022ba:	3401      	adds	r4, #1
  4022bc:	f855 3b04 	ldr.w	r3, [r5], #4
  4022c0:	4798      	blx	r3
  4022c2:	42a6      	cmp	r6, r4
  4022c4:	d1f9      	bne.n	4022ba <__libc_init_array+0x2e>
  4022c6:	bd70      	pop	{r4, r5, r6, pc}
  4022c8:	bd70      	pop	{r4, r5, r6, pc}
  4022ca:	bf00      	nop
  4022cc:	0040266c 	.word	0x0040266c
  4022d0:	0040266c 	.word	0x0040266c
  4022d4:	00402674 	.word	0x00402674
  4022d8:	0040266c 	.word	0x0040266c

004022dc <memcpy>:
  4022dc:	4684      	mov	ip, r0
  4022de:	ea41 0300 	orr.w	r3, r1, r0
  4022e2:	f013 0303 	ands.w	r3, r3, #3
  4022e6:	d16d      	bne.n	4023c4 <memcpy+0xe8>
  4022e8:	3a40      	subs	r2, #64	; 0x40
  4022ea:	d341      	bcc.n	402370 <memcpy+0x94>
  4022ec:	f851 3b04 	ldr.w	r3, [r1], #4
  4022f0:	f840 3b04 	str.w	r3, [r0], #4
  4022f4:	f851 3b04 	ldr.w	r3, [r1], #4
  4022f8:	f840 3b04 	str.w	r3, [r0], #4
  4022fc:	f851 3b04 	ldr.w	r3, [r1], #4
  402300:	f840 3b04 	str.w	r3, [r0], #4
  402304:	f851 3b04 	ldr.w	r3, [r1], #4
  402308:	f840 3b04 	str.w	r3, [r0], #4
  40230c:	f851 3b04 	ldr.w	r3, [r1], #4
  402310:	f840 3b04 	str.w	r3, [r0], #4
  402314:	f851 3b04 	ldr.w	r3, [r1], #4
  402318:	f840 3b04 	str.w	r3, [r0], #4
  40231c:	f851 3b04 	ldr.w	r3, [r1], #4
  402320:	f840 3b04 	str.w	r3, [r0], #4
  402324:	f851 3b04 	ldr.w	r3, [r1], #4
  402328:	f840 3b04 	str.w	r3, [r0], #4
  40232c:	f851 3b04 	ldr.w	r3, [r1], #4
  402330:	f840 3b04 	str.w	r3, [r0], #4
  402334:	f851 3b04 	ldr.w	r3, [r1], #4
  402338:	f840 3b04 	str.w	r3, [r0], #4
  40233c:	f851 3b04 	ldr.w	r3, [r1], #4
  402340:	f840 3b04 	str.w	r3, [r0], #4
  402344:	f851 3b04 	ldr.w	r3, [r1], #4
  402348:	f840 3b04 	str.w	r3, [r0], #4
  40234c:	f851 3b04 	ldr.w	r3, [r1], #4
  402350:	f840 3b04 	str.w	r3, [r0], #4
  402354:	f851 3b04 	ldr.w	r3, [r1], #4
  402358:	f840 3b04 	str.w	r3, [r0], #4
  40235c:	f851 3b04 	ldr.w	r3, [r1], #4
  402360:	f840 3b04 	str.w	r3, [r0], #4
  402364:	f851 3b04 	ldr.w	r3, [r1], #4
  402368:	f840 3b04 	str.w	r3, [r0], #4
  40236c:	3a40      	subs	r2, #64	; 0x40
  40236e:	d2bd      	bcs.n	4022ec <memcpy+0x10>
  402370:	3230      	adds	r2, #48	; 0x30
  402372:	d311      	bcc.n	402398 <memcpy+0xbc>
  402374:	f851 3b04 	ldr.w	r3, [r1], #4
  402378:	f840 3b04 	str.w	r3, [r0], #4
  40237c:	f851 3b04 	ldr.w	r3, [r1], #4
  402380:	f840 3b04 	str.w	r3, [r0], #4
  402384:	f851 3b04 	ldr.w	r3, [r1], #4
  402388:	f840 3b04 	str.w	r3, [r0], #4
  40238c:	f851 3b04 	ldr.w	r3, [r1], #4
  402390:	f840 3b04 	str.w	r3, [r0], #4
  402394:	3a10      	subs	r2, #16
  402396:	d2ed      	bcs.n	402374 <memcpy+0x98>
  402398:	320c      	adds	r2, #12
  40239a:	d305      	bcc.n	4023a8 <memcpy+0xcc>
  40239c:	f851 3b04 	ldr.w	r3, [r1], #4
  4023a0:	f840 3b04 	str.w	r3, [r0], #4
  4023a4:	3a04      	subs	r2, #4
  4023a6:	d2f9      	bcs.n	40239c <memcpy+0xc0>
  4023a8:	3204      	adds	r2, #4
  4023aa:	d008      	beq.n	4023be <memcpy+0xe2>
  4023ac:	07d2      	lsls	r2, r2, #31
  4023ae:	bf1c      	itt	ne
  4023b0:	f811 3b01 	ldrbne.w	r3, [r1], #1
  4023b4:	f800 3b01 	strbne.w	r3, [r0], #1
  4023b8:	d301      	bcc.n	4023be <memcpy+0xe2>
  4023ba:	880b      	ldrh	r3, [r1, #0]
  4023bc:	8003      	strh	r3, [r0, #0]
  4023be:	4660      	mov	r0, ip
  4023c0:	4770      	bx	lr
  4023c2:	bf00      	nop
  4023c4:	2a08      	cmp	r2, #8
  4023c6:	d313      	bcc.n	4023f0 <memcpy+0x114>
  4023c8:	078b      	lsls	r3, r1, #30
  4023ca:	d08d      	beq.n	4022e8 <memcpy+0xc>
  4023cc:	f010 0303 	ands.w	r3, r0, #3
  4023d0:	d08a      	beq.n	4022e8 <memcpy+0xc>
  4023d2:	f1c3 0304 	rsb	r3, r3, #4
  4023d6:	1ad2      	subs	r2, r2, r3
  4023d8:	07db      	lsls	r3, r3, #31
  4023da:	bf1c      	itt	ne
  4023dc:	f811 3b01 	ldrbne.w	r3, [r1], #1
  4023e0:	f800 3b01 	strbne.w	r3, [r0], #1
  4023e4:	d380      	bcc.n	4022e8 <memcpy+0xc>
  4023e6:	f831 3b02 	ldrh.w	r3, [r1], #2
  4023ea:	f820 3b02 	strh.w	r3, [r0], #2
  4023ee:	e77b      	b.n	4022e8 <memcpy+0xc>
  4023f0:	3a04      	subs	r2, #4
  4023f2:	d3d9      	bcc.n	4023a8 <memcpy+0xcc>
  4023f4:	3a01      	subs	r2, #1
  4023f6:	f811 3b01 	ldrb.w	r3, [r1], #1
  4023fa:	f800 3b01 	strb.w	r3, [r0], #1
  4023fe:	d2f9      	bcs.n	4023f4 <memcpy+0x118>
  402400:	780b      	ldrb	r3, [r1, #0]
  402402:	7003      	strb	r3, [r0, #0]
  402404:	784b      	ldrb	r3, [r1, #1]
  402406:	7043      	strb	r3, [r0, #1]
  402408:	788b      	ldrb	r3, [r1, #2]
  40240a:	7083      	strb	r3, [r0, #2]
  40240c:	4660      	mov	r0, ip
  40240e:	4770      	bx	lr

00402410 <memset>:
  402410:	b470      	push	{r4, r5, r6}
  402412:	0784      	lsls	r4, r0, #30
  402414:	d046      	beq.n	4024a4 <memset+0x94>
  402416:	1e54      	subs	r4, r2, #1
  402418:	2a00      	cmp	r2, #0
  40241a:	d041      	beq.n	4024a0 <memset+0x90>
  40241c:	b2cd      	uxtb	r5, r1
  40241e:	4603      	mov	r3, r0
  402420:	e002      	b.n	402428 <memset+0x18>
  402422:	1e62      	subs	r2, r4, #1
  402424:	b3e4      	cbz	r4, 4024a0 <memset+0x90>
  402426:	4614      	mov	r4, r2
  402428:	f803 5b01 	strb.w	r5, [r3], #1
  40242c:	079a      	lsls	r2, r3, #30
  40242e:	d1f8      	bne.n	402422 <memset+0x12>
  402430:	2c03      	cmp	r4, #3
  402432:	d92e      	bls.n	402492 <memset+0x82>
  402434:	b2cd      	uxtb	r5, r1
  402436:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  40243a:	2c0f      	cmp	r4, #15
  40243c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  402440:	d919      	bls.n	402476 <memset+0x66>
  402442:	f103 0210 	add.w	r2, r3, #16
  402446:	4626      	mov	r6, r4
  402448:	3e10      	subs	r6, #16
  40244a:	2e0f      	cmp	r6, #15
  40244c:	f842 5c10 	str.w	r5, [r2, #-16]
  402450:	f842 5c0c 	str.w	r5, [r2, #-12]
  402454:	f842 5c08 	str.w	r5, [r2, #-8]
  402458:	f842 5c04 	str.w	r5, [r2, #-4]
  40245c:	f102 0210 	add.w	r2, r2, #16
  402460:	d8f2      	bhi.n	402448 <memset+0x38>
  402462:	f1a4 0210 	sub.w	r2, r4, #16
  402466:	f022 020f 	bic.w	r2, r2, #15
  40246a:	f004 040f 	and.w	r4, r4, #15
  40246e:	3210      	adds	r2, #16
  402470:	2c03      	cmp	r4, #3
  402472:	4413      	add	r3, r2
  402474:	d90d      	bls.n	402492 <memset+0x82>
  402476:	461e      	mov	r6, r3
  402478:	4622      	mov	r2, r4
  40247a:	3a04      	subs	r2, #4
  40247c:	2a03      	cmp	r2, #3
  40247e:	f846 5b04 	str.w	r5, [r6], #4
  402482:	d8fa      	bhi.n	40247a <memset+0x6a>
  402484:	1f22      	subs	r2, r4, #4
  402486:	f022 0203 	bic.w	r2, r2, #3
  40248a:	3204      	adds	r2, #4
  40248c:	4413      	add	r3, r2
  40248e:	f004 0403 	and.w	r4, r4, #3
  402492:	b12c      	cbz	r4, 4024a0 <memset+0x90>
  402494:	b2c9      	uxtb	r1, r1
  402496:	441c      	add	r4, r3
  402498:	f803 1b01 	strb.w	r1, [r3], #1
  40249c:	42a3      	cmp	r3, r4
  40249e:	d1fb      	bne.n	402498 <memset+0x88>
  4024a0:	bc70      	pop	{r4, r5, r6}
  4024a2:	4770      	bx	lr
  4024a4:	4614      	mov	r4, r2
  4024a6:	4603      	mov	r3, r0
  4024a8:	e7c2      	b.n	402430 <memset+0x20>
  4024aa:	bf00      	nop

004024ac <strncpy>:
  4024ac:	ea40 0301 	orr.w	r3, r0, r1
  4024b0:	079b      	lsls	r3, r3, #30
  4024b2:	b470      	push	{r4, r5, r6}
  4024b4:	d12b      	bne.n	40250e <strncpy+0x62>
  4024b6:	2a03      	cmp	r2, #3
  4024b8:	d929      	bls.n	40250e <strncpy+0x62>
  4024ba:	460c      	mov	r4, r1
  4024bc:	4603      	mov	r3, r0
  4024be:	4621      	mov	r1, r4
  4024c0:	f854 6b04 	ldr.w	r6, [r4], #4
  4024c4:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
  4024c8:	ea25 0506 	bic.w	r5, r5, r6
  4024cc:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
  4024d0:	d106      	bne.n	4024e0 <strncpy+0x34>
  4024d2:	3a04      	subs	r2, #4
  4024d4:	2a03      	cmp	r2, #3
  4024d6:	f843 6b04 	str.w	r6, [r3], #4
  4024da:	4621      	mov	r1, r4
  4024dc:	d8ef      	bhi.n	4024be <strncpy+0x12>
  4024de:	b1a2      	cbz	r2, 40250a <strncpy+0x5e>
  4024e0:	780c      	ldrb	r4, [r1, #0]
  4024e2:	701c      	strb	r4, [r3, #0]
  4024e4:	3a01      	subs	r2, #1
  4024e6:	3301      	adds	r3, #1
  4024e8:	3101      	adds	r1, #1
  4024ea:	b13c      	cbz	r4, 4024fc <strncpy+0x50>
  4024ec:	b16a      	cbz	r2, 40250a <strncpy+0x5e>
  4024ee:	f811 4b01 	ldrb.w	r4, [r1], #1
  4024f2:	f803 4b01 	strb.w	r4, [r3], #1
  4024f6:	3a01      	subs	r2, #1
  4024f8:	2c00      	cmp	r4, #0
  4024fa:	d1f7      	bne.n	4024ec <strncpy+0x40>
  4024fc:	b12a      	cbz	r2, 40250a <strncpy+0x5e>
  4024fe:	441a      	add	r2, r3
  402500:	2100      	movs	r1, #0
  402502:	f803 1b01 	strb.w	r1, [r3], #1
  402506:	429a      	cmp	r2, r3
  402508:	d1fb      	bne.n	402502 <strncpy+0x56>
  40250a:	bc70      	pop	{r4, r5, r6}
  40250c:	4770      	bx	lr
  40250e:	4603      	mov	r3, r0
  402510:	e7e5      	b.n	4024de <strncpy+0x32>
  402512:	bf00      	nop

00402514 <register_fini>:
  402514:	4b02      	ldr	r3, [pc, #8]	; (402520 <register_fini+0xc>)
  402516:	b113      	cbz	r3, 40251e <register_fini+0xa>
  402518:	4802      	ldr	r0, [pc, #8]	; (402524 <register_fini+0x10>)
  40251a:	f000 b805 	b.w	402528 <atexit>
  40251e:	4770      	bx	lr
  402520:	00000000 	.word	0x00000000
  402524:	00402535 	.word	0x00402535

00402528 <atexit>:
  402528:	2300      	movs	r3, #0
  40252a:	4601      	mov	r1, r0
  40252c:	461a      	mov	r2, r3
  40252e:	4618      	mov	r0, r3
  402530:	f000 b814 	b.w	40255c <__register_exitproc>

00402534 <__libc_fini_array>:
  402534:	b538      	push	{r3, r4, r5, lr}
  402536:	4d07      	ldr	r5, [pc, #28]	; (402554 <__libc_fini_array+0x20>)
  402538:	4c07      	ldr	r4, [pc, #28]	; (402558 <__libc_fini_array+0x24>)
  40253a:	1b2c      	subs	r4, r5, r4
  40253c:	10a4      	asrs	r4, r4, #2
  40253e:	d005      	beq.n	40254c <__libc_fini_array+0x18>
  402540:	3c01      	subs	r4, #1
  402542:	f855 3d04 	ldr.w	r3, [r5, #-4]!
  402546:	4798      	blx	r3
  402548:	2c00      	cmp	r4, #0
  40254a:	d1f9      	bne.n	402540 <__libc_fini_array+0xc>
  40254c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  402550:	f000 b890 	b.w	402674 <_fini>
  402554:	00402684 	.word	0x00402684
  402558:	00402680 	.word	0x00402680

0040255c <__register_exitproc>:
  40255c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  402560:	4c25      	ldr	r4, [pc, #148]	; (4025f8 <__register_exitproc+0x9c>)
  402562:	6825      	ldr	r5, [r4, #0]
  402564:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
  402568:	4606      	mov	r6, r0
  40256a:	4688      	mov	r8, r1
  40256c:	4692      	mov	sl, r2
  40256e:	4699      	mov	r9, r3
  402570:	b3c4      	cbz	r4, 4025e4 <__register_exitproc+0x88>
  402572:	6860      	ldr	r0, [r4, #4]
  402574:	281f      	cmp	r0, #31
  402576:	dc17      	bgt.n	4025a8 <__register_exitproc+0x4c>
  402578:	1c43      	adds	r3, r0, #1
  40257a:	b176      	cbz	r6, 40259a <__register_exitproc+0x3e>
  40257c:	eb04 0580 	add.w	r5, r4, r0, lsl #2
  402580:	2201      	movs	r2, #1
  402582:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
  402586:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
  40258a:	4082      	lsls	r2, r0
  40258c:	4311      	orrs	r1, r2
  40258e:	2e02      	cmp	r6, #2
  402590:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
  402594:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
  402598:	d01e      	beq.n	4025d8 <__register_exitproc+0x7c>
  40259a:	3002      	adds	r0, #2
  40259c:	6063      	str	r3, [r4, #4]
  40259e:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
  4025a2:	2000      	movs	r0, #0
  4025a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4025a8:	4b14      	ldr	r3, [pc, #80]	; (4025fc <__register_exitproc+0xa0>)
  4025aa:	b303      	cbz	r3, 4025ee <__register_exitproc+0x92>
  4025ac:	f44f 70c8 	mov.w	r0, #400	; 0x190
  4025b0:	f3af 8000 	nop.w
  4025b4:	4604      	mov	r4, r0
  4025b6:	b1d0      	cbz	r0, 4025ee <__register_exitproc+0x92>
  4025b8:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
  4025bc:	2700      	movs	r7, #0
  4025be:	e880 0088 	stmia.w	r0, {r3, r7}
  4025c2:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
  4025c6:	4638      	mov	r0, r7
  4025c8:	2301      	movs	r3, #1
  4025ca:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
  4025ce:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
  4025d2:	2e00      	cmp	r6, #0
  4025d4:	d0e1      	beq.n	40259a <__register_exitproc+0x3e>
  4025d6:	e7d1      	b.n	40257c <__register_exitproc+0x20>
  4025d8:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
  4025dc:	430a      	orrs	r2, r1
  4025de:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
  4025e2:	e7da      	b.n	40259a <__register_exitproc+0x3e>
  4025e4:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
  4025e8:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
  4025ec:	e7c1      	b.n	402572 <__register_exitproc+0x16>
  4025ee:	f04f 30ff 	mov.w	r0, #4294967295
  4025f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4025f6:	bf00      	nop
  4025f8:	0040265c 	.word	0x0040265c
  4025fc:	00000000 	.word	0x00000000

00402600 <all_twi_definitions>:
  402600:	40018000 40018100 00000013 00000013     ...@...@........
  402610:	4001c000 4001c100 00000014 00000014     ...@...@........

00402620 <all_uart_definitions>:
  402620:	400e0600 400e0700 00000008 00000008     ...@...@........
  402630:	400e0800 400e0900 00000009 00000009     ...@...@........
  402640:	454c4449 00000000 20726d54 00637653     IDLE....Tmr Svc.
  402650:	6e696c42 0000796b 00000043              Blinky..C...

0040265c <_global_impure_ptr>:
  40265c:	20000010                                ... 

00402660 <_init>:
  402660:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402662:	bf00      	nop
  402664:	bcf8      	pop	{r3, r4, r5, r6, r7}
  402666:	bc08      	pop	{r3}
  402668:	469e      	mov	lr, r3
  40266a:	4770      	bx	lr

0040266c <__init_array_start>:
  40266c:	00402515 	.word	0x00402515

00402670 <__frame_dummy_init_array_entry>:
  402670:	004000f1                                ..@.

00402674 <_fini>:
  402674:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402676:	bf00      	nop
  402678:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40267a:	bc08      	pop	{r3}
  40267c:	469e      	mov	lr, r3
  40267e:	4770      	bx	lr

00402680 <__fini_array_start>:
  402680:	004000cd 	.word	0x004000cd
